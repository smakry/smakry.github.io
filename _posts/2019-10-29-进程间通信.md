---
layout: post
title: '进程间通信'
date: 2019-10-29
author: smakry
tags: 进程间通信 阅读笔记
---

> 你我怎么联系 

## 目录  

- [管道pipe](#list_1)


---

### <span id = "list_0"></span> 多进程  

#### 创建进程  

- Linux系统创建进程的方式有2种，由`操作系统创建`，还有就是`由父进程创建`（通常是子进程）。系统调用fork()创建一个新进程，vfork()也可创建，但vfork()实际也是调用fork（）函数。  
- 调用fork()之后，父进程和子进程的`执行顺序是我们无法确定`（CPU调度）  
- 创建进程成功后，父子进程都从`fork()之后开始执行`，只是pid不同，fork()成功之后，子进程获取到了父进程的`所有变量、环境变量、程序计数器的当前空间和值`（进程重新开辟了空间，这些变量的当前值拷贝）  
- 创建进程：

pid_t fork(); //pid_t是宏实际是int，返回值：`父进程中返回子进程pid`，`子进程返回0`，出错返回-1  

- vfork()函数（也是创建一个进程，返回值同fork()）：  
    - 执行顺序：
        - fork()父子进程调用顺序由CPU调度
        - vfork()先调用子进程，等子进程exit(1)被调用后再调用父进程  

    - 地址空间：  
        - fork()拥有自己的独立空间
        - vfork()子进程在调用exit之前是在父进程中运行，共享代码区和数据区，共享地址空间

#### 进程通信  

进程拥有自己`独立的地址空间`，一个进程的全局变量在另一个进程是看不到，需要通过内核实现交换数据。内核通过开辟一块`内核缓冲区`，进程A把数据从用户空间拷贝到内核缓冲区，进程B再从内核缓冲区读取数据。不同进程间的通信本质是`进程之间可以看到一份公共资源`（提供公共资源的方式和提供者的不同通信方式不同）。

![进程概述](https://github.com/smakry/smakry.github.io/raw/master/imags/%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0.png)  

### <span id = "list_1"></span> 管道pipe  

管道是一种最基本的IPC（Inter-Process Communication，进程间通信），作用于`有血缘关系的进程之间`，在进程间构建了一个`单向数据流动`的通道，数据通过一个进程流向另一个进程（`不能流向自己`）具有先后顺序，所以是`半双工通信`。面向字节流，管道随进程，进程消失管道也消失。  

- 管道的本质：是一个`伪文件`（linux一切皆文件，实际是`内核缓冲区`，是`一块内存区域`）  
- 管道的原理：内核使用`环形队列`，借助内核缓冲区（4K，这4k来自操作系统的系统内存？）实现  
- 创建管道：  
int pipe(int pipefd[2]); 成功：0； 失败：-1，设置errno   
创建成功后返回r/w两个文件描述符存放在pipefd，即`pipefd[0]->r`,`pipefd[1]->w`；`无需open`，但`需手动close`。管道文件的读写数据实际就是读写内核缓冲区。  

![创建管道](https://github.com/smakry/smakry.github.io/raw/master/imags/%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93.png)  

★上图对应的是`父子进程间`通信：  

```cpp
#include<iostream>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<stdio.h>
#include<sys/wait.h>

int main(){
    pid_t pid;
    int fd[2];

    if(pipe(fd) == -1){
        perror("pipe err");
        exit(1);
    }

    pid = fork(); //创建子进程，fork父进程中返回子进程fd，子进程中返回0表示当前子进程
    if(pid < 0){
        perror("fork err");
        exit(1);
    }
    else if(pid == 0){
        close(fd[1]);

        char buf[1024];
        int len = read(fd[0],buf,sizeof(buf));
        std::cout << len << " " << buf << std::endl;

        close(fd[0]);
    }
    else{
        close(fd[0]);

        char msg[] = "this is parent write";
        write(fd[1],msg,strlen(msg) + 1);
        wait(NULL);

        close(fd[1]);
    }

    return 0;
}

```

★`兄弟进程间`通信：  

```cpp  
#include<iostream>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<stdio.h>
#include<sys/wait.h>

int main(){
    int fd[2];

    if(pipe(fd) == -1){
        perror("pipe err");
        exit(1);
    }

    pid_t pid1 = fork(); //创建进程1用于写数据
    if(pid1 < 0){
        perror("fork err");
        exit(1);
    }
    else if(pid1 == 0){
        close(fd[0]);

        char msg[] = "this is pid1 write";
        write(fd[1],msg,strlen(msg) + 1);
        wait(NULL);

		exit(1);
        close(fd[1]);
    }

    pid_t pid2 = fork(); //创建进程2用于读数据
    if(pid2 < 0){
        perror("fork err");
        exit(1);
    }
    else if(pid2 == 0){
        close(fd[1]);

        char buf[1024];
        int len = read(fd[0],buf,sizeof(buf));
        std::cout << len << " " << buf << std::endl;

        close(fd[0]);
		exit(1);
    }
	//关闭父进程读写
    else{
        close(fd[0]);
        close(fd[1]);
        exit(1);
    }

    return 0;
}

```


#### 管道局限
    -  不能流向自己，数据自己读不能自己写  
    -  数据一旦被读走，便不在管道中了  
    -  半双工通信，只能在一个方向上流动（要双向需多进程）  
    -  只能在`有公共祖先`的进程间使用管道（没有祖先不知道流动关系）  

#### 管道读写  

管道读写以下特殊情况（`假设都是阻塞I/O操作`，没有设置O_NONBLOCK标志）。

- 读管道  
    - 管道中有数据，read返回的实际读到的字节数  
    - 管道中无数据：  
        - 管道写端全部关闭，read返回0（类似读到文件末尾）
        - 管道还有写端未关闭，read阻塞等待，当有新的write数据到达，此时会让出CPU 

- 写管道
    - 管道读端全部关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程不终止）  
    - 管道还有读端未关闭：
        - 管道已满，write阻塞
        - 管道未满，write将数据写入，并返回实际写入的字节数  



<https://blog.csdn.net/qq_42914528/article/details/82023408>