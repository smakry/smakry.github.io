---
layout: post
title: '进程间通信'
date: 2019-10-29
author: smakry
tags: 进程间通信 阅读笔记
---

> 你我怎么联系 

## 目录  

- [管道pipe](#list_1)
- [Socket套接字](#list_2)

---

### <span id = "list_0"></span> 多进程  

#### 创建进程  

- Linux系统创建进程的方式有2种，由`操作系统创建`，还有就是`由父进程创建`（通常是子进程）。系统调用fork()创建一个新进程，vfork()也可创建，但vfork()实际也是调用fork()函数。  
- 调用fork()之后，父进程和子进程的`执行顺序是我们无法确定`（CPU调度）  
- 创建进程成功后，父子进程都从`fork()之后开始执行`，只是pid不同，fork()成功之后，子进程获取到了父进程的`所有变量、环境变量、程序计数器的当前空间和值`（进程重新开辟了空间，这些变量的当前值拷贝）  
- 创建进程：

pid_t fork(); //pid_t是宏实际是int，返回值：`父进程中返回子进程pid`，`子进程返回0`，出错返回-1  

- vfork()函数（也是创建一个进程，返回值同fork()）：  
    - 执行顺序：
        - fork()父子进程调用顺序由CPU调度
        - vfork()先调用子进程，等子进程exit(1)被调用后再调用父进程  

    - 地址空间：  
        - fork()拥有自己的独立空间
        - vfork()子进程在调用exit之前是在父进程中运行，共享代码区和数据区，共享地址空间

#### 进程通信  

进程拥有自己`独立的地址空间`，一个进程的全局变量在另一个进程是看不到，需要通过内核实现交换数据。内核通过开辟一块`内核缓冲区`，进程A把数据从用户空间拷贝到内核缓冲区，进程B再从内核缓冲区读取数据。不同进程间的通信本质是`进程之间可以看到一份公共资源`（提供公共资源的方式和提供者的不同通信方式不同）。

![进程概述](https://github.com/smakry/smakry.github.io/raw/master/imags/%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0.png)  

### <span id = "list_1"></span> 管道pipe  

管道是一种最基本的IPC（Inter-Process Communication，进程间通信），作用于`有血缘关系的进程之间`，在进程间构建了一个`单向数据流动`的通道，数据通过一个进程流向另一个进程（`不能流向自己`）具有先后顺序，所以是`半双工通信`。面向字节流，管道随进程，进程消失管道也消失。  

- 管道的本质：是一个`伪文件`（linux一切皆文件，实际是`内核缓冲区`，是`一块内存区域`）  
- 管道的原理：内核使用`环形队列`，借助内核缓冲区（4K，这4k来自操作系统的系统内存？）实现  
- 创建管道：  
int pipe(int pipefd[2]); 成功：0； 失败：-1，设置errno   
创建成功后返回r/w两个文件描述符存放在pipefd，即`pipefd[0]->r`,`pipefd[1]->w`；`无需open`，但`需手动close`。管道文件的读写数据实际就是读写内核缓冲区。  

![创建管道](https://github.com/smakry/smakry.github.io/raw/master/imags/%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93.png)  

★上图对应的是`父子进程间`通信：  

```cpp
#include<iostream>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<stdio.h>
#include<sys/wait.h>

int main(){
    pid_t pid;
    int fd[2];

    if(pipe(fd) == -1){
        perror("pipe err");
        exit(1);
    }

    pid = fork(); //创建子进程，fork父进程中返回子进程fd，子进程中返回0表示当前子进程
    if(pid < 0){
        perror("fork err");
        exit(1);
    }
    else if(pid == 0){
        close(fd[1]);

        char buf[1024];
        int len = read(fd[0],buf,sizeof(buf));
        std::cout << len << " " << buf << std::endl;

        close(fd[0]);
    }
    else{
        close(fd[0]);

        char msg[] = "this is parent write";
        write(fd[1],msg,strlen(msg) + 1);
        wait(NULL);

        close(fd[1]);
    }

    return 0;
}

```

★`兄弟进程间`通信：  

```cpp  
#include<iostream>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<stdio.h>
#include<sys/wait.h>

int main(){
    int fd[2];

    if(pipe(fd) == -1){
        perror("pipe err");
        exit(1);
    }

    pid_t pid1 = fork(); //创建进程1用于写数据
    if(pid1 < 0){
        perror("fork err");
        exit(1);
    }
    else if(pid1 == 0){
        close(fd[0]);

        char msg[] = "this is pid1 write";
        write(fd[1],msg,strlen(msg) + 1);
        wait(NULL);

		exit(1);
        close(fd[1]);
    }

    pid_t pid2 = fork(); //创建进程2用于读数据
    if(pid2 < 0){
        perror("fork err");
        exit(1);
    }
    else if(pid2 == 0){
        close(fd[1]);

        char buf[1024];
        int len = read(fd[0],buf,sizeof(buf));
        std::cout << len << " " << buf << std::endl;

        close(fd[0]);
		exit(1);
    }
	//关闭父进程读写
    else{
        close(fd[0]);
        close(fd[1]);
        exit(1);
    }

    return 0;
}

```


#### 管道局限
    -  不能流向自己，数据自己读不能自己写  
    -  数据一旦被读走，便不在管道中了  
    -  半双工通信，只能在一个方向上流动（要双向需多进程）  
    -  只能在`有公共祖先`的进程间使用管道（没有祖先不知道流动关系）  

#### 管道读写  

管道读写以下特殊情况（`假设都是阻塞I/O操作`，没有设置O_NONBLOCK标志）。

- 读管道  
    - 管道中有数据，read返回的实际读到的字节数  
    - 管道中无数据：  
        - 管道写端全部关闭，read返回0（类似读到文件末尾）
        - 管道还有写端未关闭，read阻塞等待，当有新的write数据到达，此时会让出CPU 

- 写管道
    - 管道读端全部关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程不终止）  
    - 管道还有读端未关闭：
        - 管道已满，write阻塞
        - 管道未满，write将数据写入，并返回实际写入的字节数  

#### 有名管道（在此之前描述的都是无名管道）  

管道的不足就是没有名字只能在有血缘关系的进程间通信，有名管道赋予管道名字实现在`不同进程之间（没有血缘关系）`通信。有名管道的实现是以FIFO（fisrt in first out）的文件形式存储于文件系统（管道文件）。这个文件是以先进先出的方式流动读写。Linux下创建有名管道的可以使用`mknod和mkfifo命令`，还有就是通过`系统函数`：
int mkfifo(const char *pathname, mode_t mode);  
int mknod(const char *pathname, mode_t mode, dev_t dev);  

```cpp
//写进程
#include<iostream>
#include<stdio.h>

int main(){
    FILE* out_file;
    int count = 1;
    char buf[80];

    out_file = fopen("mypipe","w");
    if(out_file == NULL){
        std::cout << "file open err" << std::endl;
        exit(1);
    }

    sprintf(buf,"this is test data for the name pipe for example\n");
    fwrite(buf,1,80,out_file);
    fclose(out_file);

    return 1;
}


```


```cpp
//写进程
#include<iostream>
#include<stdio.h>

int main(){
    FILE* in_file;
    int count = 1;
    char buf[80];

    in_file = fopen("mypipe","r");
    if(in_file == NULL){
        std::cout << "fileopen err" << std::endl;
        exit(1);
    }

    while((count = fread(buf,1,80,in_file)) > 0){
        std::cout << buf << std::endl;
        fclose(in_file);
    }

    return 1;
}

```

<https://blog.csdn.net/qq_42914528/article/details/82023408>  


### <span id = "list_2"></span> Socket套接字（实现在不同机器间的通信）  

#### 网络中进程如何通信  

网络中通信需解决与哪台主机哪个进程进行通信：  

- 标识唯一主机：本地是通过pid标识，网络中TCP/IP协议族的网络层`“IP地址”可以唯一标识网络中的主机`  
- 标识唯一进程：网络中传输层的`“协议+端口”可以唯一标识主机中的应用程序（进程）`，因此利用三元组（IP地址、协议、端口）就可以标识网络的进程。
#### Socket通信  

Socket利用三元组【IP地址、协议、端口】进行网络通信，socket是解决网络通信的一个中间件工具。函数原型：  

int socket(int domain, int type, int protocol);
  
- domain或者说af地址族（Address Family），就是IP地址类型，常用的AF_INET和AF_INET6（INET是Internet简写）  
- type为数据传输方式，常用的有SOCK_STREAM（TCP，例如网页采用这种）和SOCK_DGRAM(UDP，例如QQ视频采用这种)
- protocol表示传输协议，常用的有IPPROTO_TCP（TCP）和IPPROTO_UDP（UDP）
- 返回值：文件描述符fd标识该sockt  
- socket创建成功后`分配两个缓冲区`（I/O模型）：输入缓冲区和输出缓冲区  
    - I/O缓冲区在`每个`TCP套接字中`单独存在`
    - I/O缓冲区创建套接字后`自动生成`
    - 关闭套接字`输出`缓冲区的数据会`继续`传输
    - 关闭套接字`输入`缓冲区数据会`丢失` 

![socket中TCP三次握手](https://github.com/smakry/smakry.github.io/raw/master/imags/socket%E4%B8%ADTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

![socket中TCP四次挥手](https://github.com/smakry/smakry.github.io/raw/master/imags/socket%E4%B8%ADTCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

listen()函数让套接字进入`被动监听状态（唤醒套接字）`，此时还没有接收请求  
accept()函数接收客户端请求，此时`程序阻塞执行`（后面代码不能被执行），知道有新的请求  


<https://www.jianshu.com/p/066d99da7cbd>
<https://www.cnblogs.com/clschao/articles/9585555.html>
<https://blog.csdn.net/liuxingen/article/details/44995467>
