---
layout: post
title: '服务器优化'
date: 2019-11-18
author: smakry
tags: 优化 阅读笔记
---

>  







内存分配：降低内存、减少碎片（分配阻塞导致性能低）  
直接分配固定的内存数、同verctor容器的增长方式、
彻底接管内存分配、  
1.预分配的内存大小大于所需的（减少分配）  
2.对象销毁后对象不直接交换操作系统而是插入到预分配表中（减少分配）  


内存对齐（减少寻址的时间，未对齐需寻址多次，涉及到CPU架构是否存在寻址问题）、  



多线程：异步到不同的线程去计算，减少主逻辑的等待  
修改完成端口启动的线程数目，提高CPU使用率  
所有玩家的逻辑都在一个线程处理，考虑多线程的可行性  


以上基于单服优化，效果不佳拆分服务器（各种功能的游戏逻辑、聊天、数据服务器等）  



1.内存对齐  
2.拷贝代码为了效率（减少面向对象的过程）  
3.尽量使用位运算  
4.堆申请的内存需初始化、里面的是垃圾数据并非空  
5.不追求代码的简洁（如递归的方式我们使用的是循环减少堆栈开销）  
6.面向对象编程：可维护、可复用、可扩展、灵活性好  
7.频繁使用的代码里面，尽量少使用容器，容器创建和回收的开销很大  
8.字符串拼接memcpy效率最高，string类的+=效率特别高，strcat效率很差，append也不快  
9.不过度的继承（构造及析构都需层次调用到）  
10.构造函数不使用值初始化（再次构造对象）  
11.变量延时定义（定义过程没使用会出现没使用的浪费）  
12.频繁的申请和释放对象建议使用内存池管理（减少内存碎片）  
13.内联减少函数调用带来的消耗  
14.缓存：多次使用的计算结果及时缓存、避免重复计算  
15.延迟计算：对于不关心的计算结果的计算过程尽量延迟执行或者异步去执行  
16.多线程减少锁的使用  
17.智能指针使用是必须（大大降低程序的crash频率（碰撞冲突）），但需要额外开销，底层是原子操作来统计引用数和一个普通指针  
18.返回值减少拷贝操作  
19.算法层面  
20.事件驱动（事件发生了才去执行相关逻辑，不放到update轮循中耗费cpu事件处理）    
21.减少数据读写I/O  
22.sql优化  
23.多余或者无用的功能和计算  
24.传统服务器架构很难修改，功能剥离创建线程或者程序进程处理，充分利用计算机资源  
25.数据库读写瓶颈，建立单独数据库服务器，并尽量使用异步读写  
26.使用map，程序中使用vector造成查找慢  
27.log采样和分析，实际环境进行优化  



TCP长连接（心跳保持）  
TCP短连接（一次收发都重新建立一个TCP连接，如果HTTP）  

===================  


服务器架构：  
网络通讯（通信模型、数据转发、心跳检测）  
业务逻辑（角色管理、地图场景、副本逻辑、AI、战斗技能、常规功能和各种玩法）  
数据存储（角色数据存储、功能模块数据存储）  
守护进程(监控服务器的CPU，内存使用状态，各个进程的运行状态，如果发现某一个服务器进程死掉及时重启，还有一些全局自然的分配也可以由这个进程实现，例如共享内存)  





