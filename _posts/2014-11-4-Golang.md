# 目录
- [1. 空的for循环CPU如何变化](#空的for循环CPU如何变化)
- [2. goroutine的调度原理](#goroutine的调度原理)
- [3. struct能不能比较](#struct能不能比较)
- [4. defer原理](#defer原理)
- [5. select的使用场景](#select的使用场景)
- [6. context包的用途](#context包的用途)
- [7. Go主协程如何等待其它协程结束再操作](#Go主协程如何等待其它协程结束再操作)
- [8. map如何顺序读取](#map如何顺序读取)
- [9. set数据结构实现](#set数据结构实现)
- [10. HTTP请求如何保持keep-alive](#HTTP请求如何保持keep-alive)
- [11. slice与数组的区别，slice底层数据结构](#slice与数组的区别-slice底层数据结构)
- [12. channel底层实现原理](#channel底层实现原理)
- [13. Go退出程序时怎么防止channel未消费完](#Go退出程序时怎么防止Channel未消费完)
- [14. sync.Pool原理为什么要使用](#sync.Pool原理为什么要使用)
- [15. Go开发踩过什么坑](#Go开发踩过什么坑)
- [16. Go优缺点](#Go优缺点) 
- [17. Go锁如何实现](#Go锁如何实现)
- [18. Go里面SQL连接池实现原理](#Go里面SQL连接池实现原理)
- [19. Go什么情况下会发生内存泄露](#Go什么情况下会发生内存泄露)
- [20. Go怎么实现协程完美退出](#Go怎么实现协程完美退出)
- [21. Go为什么高并发那么好](#Go为什么高并发那么好)
- [22. interface怎么理解](#interface怎么理解)
- [23. map是并发安全的吗](#map是并发安全的吗)
- [24. 数据经过channel传递的时候会被复制，这个复制是浅拷贝还是深拷贝](#数据经过channel传递的时候会被复制-这个复制是浅拷贝还是深拷贝)
- [25. select语句中发现某个channel已经关闭，如何屏蔽掉它的分支](#select语句中发现某个channel已经关闭-如何屏蔽掉它的分支)
- [26. select与for一起使用的时候，如何退出外层循环](#select与for一起使用的时候-如何退出外层循环)
- [27. struct{}代表了什么有什么用处](#struct{}代表了什么有什么用处)
- [28. 如何限制goroutine的数量](#如何限制goroutine的数量)
- [29. Context值在传递撤销信号的时候是广度优先还是深度优先](#Context值在传递撤销信号的时候是广度优先还是深度优先)
- [30. Golang垃圾回收算法](#Golang垃圾回收算法)
- [31. Golang里的逃逸分析是什么，怎么避免内存逃逸](#Golang里的逃逸分析是什么怎么避免内存逃逸)
- [33. Golang 的 GC 触发时机是什么](#Golang的GC触发时机是什么)
- [33. 为什么选用Gin做为HTTP API Service框架](#为什么选用Gin做为HTTP-API-Service框架)
- [33. 对比一下Golang和Java的GC](#对比一下Golang和Java的GC)

# 问题

## 空的for循环CPU如何变化?
1. 如果是默认使用单核CPU情况下，会直接把CPU跑满，几乎所有的CPU时间片都用来处理空循环了
   ```
    PID   USER  PR  NI  VIRT   RES  SHR S %CPU %MEM  TIME+   COMMAND
    2635  cgl   20  0   99.4m  4620 344 R 99.9  0.1  0:39.72 cgl-test
   ```

## goroutine的调度原理
1. Go使用以下3个实体来描述 goroutine、thread 和 processor
   + `P`: processor（Golang实现的调度处理器，每个CPU核只能运行一个P，可以通过设置 GOMAXPROCS 来控制 P 的个数）
   + `M`: OS thread (系统线程，用来运行goroutine，同一时刻一个 P 只能运行一个 M，M可以随时创建销毁)
   + `G`: goroutine（用户级协程，每个 M 支持数十万个G (goroutine）)
2. 通过这3个，Go就可以实现`M:N`的调度，也就是M个goroutine可以运行在N个系统线程上，任何时候每个系统线程 M 都可以执行一个G goroutine，如果某个G goroutine阻塞，系统线程 M 会切换执行另外一个G goroutine，所以goroutine阻塞并不会导致系统线程阻塞，这就大大提高了程序并发处理能力
3. 每个P 带有一个本地goroutine queue 以及 一个全局goroutine queue，存储可运行的goroutine，goroutine运行结束之后删除掉
4. 如果某个P 本地goroutine queue为空，那它会随机从其它 P 中获取一半可运行goroutine
5. 总的来说: Go 调度器做了很多工作，避免过多的抢占操作系统的线程

![](https://rakyll.org/img/scheduler-concepts.png)
![](https://rakyll.org/img/scheduler-stealing.png)
![](https://miro.medium.com/max/1400/1*ntxTfMNaxclAE7AJgBuAtw.png)
![](https://miro.medium.com/max/1400/1*bGkWfuAGbHK9r1lFpukYpw.png)
![](https://miro.medium.com/max/1400/1*Q7_pAxBx1q4C8MUTHQ3oDg.png)

goroutine相比于系统线程有以下几个优点
1. 内存消耗: 创建一个goroutine需要2KB的内存，创建一个系统线程需要1M的内存
2. 创建和销毁的成本: 系统线程创建和销毁必须跟操作系统进行交互，成本比较大；goroutine的创建和销毁是通过go 运行时控制的，非常方便。
3. 切换成本: 系统线程是抢占式调度的，运行超过CPU时间片后，会被其它线程抢占，切换之后需要保存 `程序计数器`、`栈地址` 等寄存器数据；goroutine调度是协作式的，它并不直接跟操作系统进行交互，没有调度时间片的概念，切换之后只需要保存很少的寄存器数据。

## struct能不能比较
1. struct值可以比较
   ```
   type s struct {
       name string
       age  int
   }

   a := s{
       name: "cgl",
       age:  11,
   }

   b := s{
       name: "cgl",
       age:  11,
   }

   if a == b {
       fmt.Println("equal")
   } else {
       fmt.Println("not equal")
   }
   
   会输出 equal
   ```
   1). 如果全部项的值都相等，这两个结构体类型的值才相等，否则不相等  
   2). 只有两个结构体类型是相同类型时才可以比较，相同结构体类型是说它们项的顺序、名称、类型、标签都相同
2. struct类型指针也可以比较
   ```
   type s struct {
       name string
       age  int
   }

   a := &s{
       name: "cgl",
       age:  11,
   }

   b := &s{
       name: "cgl",
       age:  11,
   }

   if a == b {
       fmt.Println("equal")
   } else {
       fmt.Println("not equal")
   }
   
   会输出 not equal
   ```

## defer原理
Go defer有以下3条规则

1. `延迟函数的参数在defer语句出现时就已经确定下来了`
   ```
   func a() {
       i := 0
       defer fmt.Println(i)
       
       i++
       return
   }
   ```
   结果输出为 `0`  (defer语句中的fmt.Println()参数i值在defer出现时就已经确定下来，后面对变量i的修改不会影响fmt.Println()函数的执行，仍然打印0)
2. `延迟函数执行按后进先出顺序执行，即先出现的defer最后执行`
   + 定义defer类似于入栈操作，执行defer类似于出栈操作
   + 设计defer的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再跟据A资源申请B资源，跟据B资源申请C资源，即申请顺序是:A-->B-->C
   + 每申请到一个用完需要释放的资源时，立即定义一个defer来释放资源是个很好的习惯
3. `延迟函数可能操作主函数的具名返回值`
   ```
   func deferFuncReturn() (result int) {    
       i := 1

       defer func() {
           result++
       }()    
       
       return i
   }
   ```
   结果输出为 `2` (return不是一个原子操作，实际上return只代理汇编指令ret，即将跳转程序执行。比如语句return i，实际上分两步进行，即将i值存入栈中作为返回值，然后执行跳转，而defer的执行时机正是跳转前，所以说defer执行时还是有机会操作返回值的) 
   
源码包`src/src/runtime/runtime2.go:_defer`定义了defer的数据结构
```
type _defer struct {
    sp      uintptr   //函数栈指针
    pc      uintptr   //程序计数器
    fn      *funcval  //函数地址
    link    *_defer   //指向自身结构的指针，用于链接多个defer
}
```

defer后面一定要接一个函数的，所以defer的数据结构跟一般函数类似，也有栈地址、程序计数器、函数地址等等。与函数不同的一点是它含有一个指针，可用于指向另一个defer，每个goroutine数据结构中实际上也有一个defer指针，该指针指向一个defer的单链表，每次声明一个defer时就将defer插入到单链表表头，每次执行defer时就从单链表表头取出一个defer执行。

![](https://oscimg.oschina.net/oscnet/49aa3310699806c44f628de7ee28497e9b0.jpg)

从上图可以看到，新声明的defer总是添加到链表头部。函数返回前执行defer则是从链表首部依次取出执行。一个goroutine可能连续调用多个函数，defer添加过程跟上述流程一致，进入函数时添加defer，离开函数时取出defer。

源码包`src/runtime/panic.go`定义了两个方法分别用于创建defer和执行defer，简单这么理解，在编译在阶段，声明defer处插入了函数deferproc()，在函数return前插入了函数deferreturn()
1. deferproc(): 在声明defer处调用，其将defer函数存入goroutine的链表中
2. deferreturn(): 在return指令，准确的讲是在ret指令前调用，其将defer从goroutine链表中取出并执行

## select的使用场景
1. select 是Go中的一个控制结构，类似于switch语句，用于处理异步IO操作。
2. select 会监听case语句中channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作。
3. 如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。
4. 如果没有可运行的case语句，且有default语句，那么就会执行default的动作。
5. 如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行
6. 当case上读一个channel时，如果这个channel是nil，则该case永远阻塞。select通常处理的是多个channel，当某个读channel关闭了，但不想select再继续关注此case，继续处理其他case，把该通道设置为nil即可
7. break在select内并不能跳出for-select循环
   + 在满足条件的case内，使用return，如果有结尾工作，尝试交给defer
   + 在满足条件的case内，使用break 和 label
   + 在满足条件的case内，使用goto 和 label
8. select{}永远阻塞

使用场景  
1. 多channel处理
2. 超时判断: 给某个请求/处理/操作，设置超时时间，一旦超时时间内无法完成，则停止处理
   ```
   //比如在下面的场景中，使用全局resChan来接受response，如果时间超过3S,resChan中还没有数据返回，则第二条case将执行
   var resChan = make(chan int)
   // do request
   func test() {
       select {
       case data := <-resChan:
           doData(data)
       case <-time.After(time.Second * 3):
	   fmt.Println("request time out")
	}
   }
   ```
3. 退出函数
   ```
   // 通过select 判断channel是否有接收到某个信号，然后退出函数
   var shouldQuit=make(chan struct{})
   fun test(){ 
       for {
           //...out of the loop
           select {
	       case <-c.shouldQuit:
	           cleanUp()
		   return
	       default:
	   }
           //...
       }
   }
   ```

## context包的用途
1. Context 是在Go 1.7版本的时候才加入到标准库的，Context 是一种非常通用的同步工具。Context类型可以提供一类代表上下文的值，是并发安全的可以在多个goroutine中传递
3. context 代码包 包含了以下4个衍生Context的函数
   + WithCancel: 用于产生一个可撤销的Context，并返回一个撤销函数
   + WithDeadline: 用于产生一个可定时撤销的Context，并返回一个撤销函数
   + WithTimeout: 用于产生一个可定时撤销的Context，并返回一个撤销函数
   + WithValue: 用于产生一个可携带额外数据的Context
4. Go团队初衷是用来撤销某些操作，撤销的意思指的是终止程序对某种请求(例如HTTP)的响应，或者取消某种指令(例如SQL命令)的处理。
5. Context 使用原则和技巧
   + 不要把 Context 放在结构体中，要以参数的方式传递，parent Context一般为Background
   + 应该把 Context 作为第一个参数传递给入口请求和出口请求链路上的每一个函数，放在第一位，变量名统一命名为`ctx`
   + 给一个函数方法传递 Context 的时候，不要传递nil，否则在tarce追踪的时候，就会断了连接
6. 可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行撤销操作时，所有 goroutine 都会接收到取消信号
7. context.Context是一个interface类型，我们可以实现可携带数据的Context

```
// Context
// 要求实现以下4个方法
// Deadline() (deadline time.Time, ok bool)
// Done() <-chan struct{}
// Err() error
// Value(key interface{}) interface{}
type Context struct {
    values map[interface{}]interface{}
}

const (
    // TraceIDKey 常量定义
    TraceIDKey = "trace_id"
)

// DefaultTraceContext 获取默认Context实例
func DefaultTraceContext() *Context {
    return &Context{
	values: make(map[interface{}]interface{}),
    }
}

// WithTraceID 根据trace ID获取Context实例
func WithTraceID(traceID string) *Context {
    values := make(map[interface{}]interface{})
    values[TraceIDKey] = traceID
    return &Context{
	values: values,
    }
}

// GetTraceID 获取trace ID
func (tc *Context) GetTraceID() string {
    if value, ok := tc.values[TraceIDKey]; ok {
	return value.(string)
    }
    return string("")
}

// SetTraceID 设置trace ID
func (tc *Context) SetTraceID(traceID string) {
    tc.values[TraceIDKey] = traceID
}

// Deadline 默认实现
func (tc *Context) Deadline() (deadline time.Time, ok bool) {
	return
}

// Done 默认实现
func (tc *Context) Done() <-chan struct{} {
	return nil
}

// Err 默认实现
func (tc *Context) Err() error {
	return nil
}

// Value 根据key获取value
func (tc *Context) Value(key interface{}) interface{} {
	return tc.values[key]
}
```

## Go主协程如何等待其它协程结束再操作
1. 通过一个channel来实现，具体的实现原理是 `channel在没有数据的时候接收操作会一直阻塞`，当所有的协程都结束的可以close掉这个channel，这样接收操作就不会阻塞，主协程就可以继续往下执行
2. api service、processor等类型的应用通常需要监听系统信号，然后再优雅退出
   ```
   func main() {
       ...
       
       // block until shutdown channel closed
       shutdown := make(chan struct{})
       registerSignal(shutdown)
       <-shutdown
       
       ...
   }

   // registerSignal register kill signal
   func registerSignal(shutdown chan struct{}) {
       c := make(chan os.Signal)
       signal.Notify(c, os.Interrupt, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM)

       go func() {
           defer func() {
	       if err := recover(); err != nil {
	           log.Error("[registerSignal] panic error: ",
			log.Object("error", err))
		   debug.PrintStack()
	       }
	   }()

	   for sig := range c {
		// close shutdown channel
		close(shutdown)
		log.Info("[registerSignal] receive system signal:" +
		    sig.String() + ", going to shutdown ...")
		return
	   }
       }()
   }
   ```

## map如何顺序读取
1. 正常情况for循环遍历map是不稳定，key/value输出顺序会变化
   ```
   m := map[string]string {
       1:  "one",
       11: "eleven",
       3:  "three",
   }
   for k, v := range m {
       fmt.Println(k, v)
   }
   ```
2. 可以通过对key进行排序，保证遍历map输出是稳定的
   ```
   m := myIntMap{
       1:  "one",
       11: "eleven",
       3:  "three",
   }

   // To store the keys in slice in sorted order
   var keys []int
   for k := range m {
       keys = append(keys, k)
   }
   sort.Ints(keys)

   for _, k := range keys {
       fmt.Println(k, m[k])
   }
   ```

## set数据结构实现
1. Go 自身并没有提供 set 数据结构
2. https://github.com/deckarep/golang-set 开源的golang set数据结构
3. 简单的 set 实现 https://flaviocopes.com/golang-data-structure-set/
4. 自己实现的话，需要实现 Add、Delete、Clear、Has、Items等方法，并且需要保证并发安全

## HTTP请求如何保持keep-alive
1. Go HTTP Client源码包在 `src/net/http/client.go`
2. HTTP Client使用的原则
   + http.Client 零值为 DefaultClient = &Client{}，默认是可以直接使用的
   + http.Client Transport 是内部状态，会缓存TCP链接（长链接），因此建议重用http.Client 而不是每次都 New一个新的，http.Client 在多个goroutine之间使用是并发安全的
   + http.Client Timeout 从发起请求到整个报文响应结束的超时时间，如果没有设置默认为0，表示无限制
3. 常规的http Client定义如下
   ```
   // case 1 
   // Transport If nil, DefaultTransport is used.
   &http.Client{
	Timeout:   timeout,
   }
   
   // case 2
   &http.Client{
	Timeout:   timeout,
	Transport: &http.Transport{
	    ...
	},
   }
   ```
4. DefaultTransport 定义
   ```
   // DefaultTransport is the default implementation of Transport and is
   // used by DefaultClient. It establishes network connections as needed
   // and caches them for reuse by subsequent calls. It uses HTTP proxies
   // as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and
   // $no_proxy) environment variables.
   var DefaultTransport RoundTripper = &Transport{
	Proxy: ProxyFromEnvironment,               
	DialContext: (&net.Dialer{
		Timeout:   30 * time.Second,      //连接超时时间
		KeepAlive: 30 * time.Second,      //默认开启长连接
		DualStack: true, 
	}).DialContext,
	MaxIdleConns:          100,               //最大空闲连接数
	IdleConnTimeout:       90 * time.Second,  //连接最大空闲时间，超过这个时间就会被关闭
	TLSHandshakeTimeout:   10 * time.Second,  //限制TLS握手使用的时间
	ExpectContinueTimeout: 1 * time.Second,
   }
   ```
5. 由上可知 `DefaultClient` 或者 `&Client{Timeout:timeout}` 这种情况下 默认使用DefaultTransport，默认是开启了长连接了，但是
6. 完整的 http.Client 的定义如下，支持http keep-alive机制
   ```
   return &http.Client{
       Timeout: timeout, //请求发起到HTTP包响应结束超时时间
       Transport: &http.Transport{
           Proxy: http.ProxyFromEnvironment,
	   DialContext: (&net.Dialer{
	       Timeout:   30 * time.Second, //连接超时时间
	       KeepAlive: 30 * time.Second, //开启长连接
	   }).DialContext,
	   MaxIdleConns:        100, //整个接池对所有host的最大连接数量
	   MaxIdleConnsPerHost: 100, //对每个请求Host允许最大连接数，一般是Server 2 Server 设置和 MaxIdleConns 一样即可
	   IdleConnTimeout:     time.Duration(90 * time.Second),
	   TLSClientConfig:     &tls.Config{InsecureSkipVerify: true}, //忽略TLS安全校验
	},
   }
   ```
   最重要的是以下这2个参数  
   1). MaxIdleConns: 整个连接池最大的连接数    
   2). MaxIdleConnsPerHost: 对每个请求Host允许最大连接数，一般是Server 2 Server 设置和 MaxIdleConns 一样即可
   
## slice与数组的区别 slice底层数据结构
1. 数组长度是固定的，不能够动态扩容
2. slice是可以简单认为是动态数组类似C++的vector，支持动态扩容，底层数据结构是数组
   ```
   type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
   }
   ```

## channel底层实现原理
1. 可以参考 https://chenguolin.github.io/2018/07/10/Go-11-Golang-Channel%E4%BB%8B%E7%BB%8D/

## Go退出程序时怎么防止channel未消费完
1. 这个很好解决通过另外一个stop channel来实现，原理是 `如果channel为空或者channel为nil，channel的接收操作会一直阻塞`
2. 我们只需要主协程(主进程)那边收到系统关闭信号的时候，发起一个channel的close，然后stop channel一直阻塞直到被关闭
   ```
   func main() {
       ...
       
       stopChan := make(chan struct{})
       
       // goroutine 处理channel数据
       go process(stopChan)
       
       // block until stopChan closed
       <- stopChan
       
       ...
   }
   
   func process(stopChan chan struct{}) {
       // 处理另外一个channel数据
       dataChan := getDataChan() 
       
       for {
           // select会一直阻塞，需要内部自行return 或 break 或 goto
           select {
               case data, ok := <- dataChan:
	           // dataChan has closed
	           if !ok {
	               close(stopChan)
	               return
	           }
           }
       }
   }
   ```

## sync.Pool原理为什么要使用
1. sync.Pool 指的是`临时对象池`，Golang和Java具有GC机制，因此很多开发者基本上都不会考虑内存回收问题，不像C++很多时候开发需要自己回收对象。
GC是一把双刃剑，带来了编程的方便但同时也增加了运行时开销，使用不当可能会严重影响程序的性能，因此性能要求高的场景不能任意产生太多的垃圾。
2. sync.Pool 正是用来解决这类问题的，Pool可以作为临时对象池来使用，不再自己单独创建对象，而是从临时对象池中获取出一个对象。

使用参考 https://chenguolin.github.io/2018/07/09/Go-10-Golang-Sync%E5%8C%85/#%E4%B8%83-syncpool

sync.Pool 源码在 `src/sync/pool.go` 

## Go开发踩过什么坑
1. 使用for遍历map，发现输出不稳定，key/value顺序会变
2. 资源申请忘记使用defer close （数据库连接没有defer close，导致连接泄露）
3. 没有判断对象是否为nil，直接使用导致 panic
   ```
   resp, err := http.Get("https://api.ipify.org?format=json")
   defer resp.Body.Close()//如果http请求失败，resp为nil，这里会抛panic
   ```
4. map没有使用make定义，就直接使用，导致panic
5. 往一个已经关闭的channel继续发送数据，导致panic
6. for switch 或 for select 使用break无法跳出for循环
   ```
   for {
       switch age {
       case 1:
           break         //发现无法跳出for循环
       }
   }
   
   for {
       select  {
       case <- ch:
           break         //发现无法跳出for循环
       }
   }
   ```
   解决方案是使用 `break + 标签` 或者 `goto + 标签`
   ```
   Loop:
       for {
           switch age {
           case 1:
               break Loop  
           }
       }
       
   Loop:
       for {
           select  {
           case <- ch:
               break Loop
           }
       }
   ```
7. for循环内goroutine，goroutine直接使用外部变量，而不是传参数，导致数据不对
   ```
   for _, tx := range txs {
       go func() {
           fmt.Println(tx)
       }()
   }
   
   这里打印的 tx 不会符合我们的预期的，因为tx属于goroutine外部作用域，因此在goroutine 打印的时候会变
   ```  
   正确的做法应该是把参数传递给goroutine
   ```
   for _, tx := range txs {
       go func(tx *Tx) {
           fmt.Println(tx)
       }(tx)
   }
   ```
8. defer 延迟函数理解不透彻，导致预期输出和实际输出不一致
   ```
   var i int = 1
   defer fmt.Println("result =>",func() int { return i * 2 }())
   i++
   
   实际结果为2，并不是我们期望的4，因为defer延迟函数的参数在defer语句出现时就已经确定下来了，所以值为2
   ```
9. 打开大量的文件，忘记close，导致FD超过系统限制，linux默认最大的FD为`655350`，可自行设置
10. goroutine没有recover机制，panic之后导致整个进程crash

## Go优缺点
1. 优点
   + 很容易上手: 基本语法和其它高级语言差不了太多，开源并且有很完善的文档，有丰富的代码库以及第三方开源代码库供使用
   + 高并发: 相比于C++、Java，Go想要实现高并发服务非常的容易，语言级别实现了并发（goroutine实现原理）
   + SDK源码开源: 有丰富的代码库以及第三方开源代码库供使用
   + 高效的GC算法: Go 从v1.5版本之后GC的性能就非常的高，v1.9版本之后GC的延迟在 `0~0.5ms`，性能非常好
   + 丰富工具支持代码质量检测: golint、gofmt、govet等
   + 内置测试工具: 单元测试、性能测试
   + 语法简单: 数据结构和语法简单，没有类和继承，可以快速完成编码，代码容易维护
   + 静态编译: 支持跨平台运行
2. 缺点
   + 相对于C++、Java来说发布比较晚 (2006提出，2009年开源，2011年v1.0版本发布)，各种库还在完善当中
   + 无法手动管理内存: 类似C/C++里面 malloc()
   + error处理不是很优雅: 需要开发写大量的if判断

## Go锁如何实现
1. 源码包 `src/sync/mutex.go` 和 `src/sync/rwmutex.go` 内的Mutex 和 RWMutex可以实现锁的功能
2. Mutex 互斥锁: 互斥锁需要保证的是同一个时间段内不能有多个并发协程同时访问某一个资源(临界区)，支持Lock、Unlock
3. RWMutex 读写锁: 读写锁是为了能够支持多个并发协程同时读取某一个资源，但只有一个并发协程能够更新资源。也就是说读和写是互斥的，写和写也是互斥的，读和读是不互斥的，支持Lock、Unlock、RLock、RUnlock
   ```
   写操作
   func (rw *RWMutex) Lock()
   func (rw *RWMutex) Unlock()

   读操作
   func (rw *RWMutex) RLock()
   func (rw *RWMutex) RUnlock()
   ```
   1). 当有一个协程获得`读锁 RLock`的时候，所有`读`的协程不受影响，都可以获得`读锁 RLock`进行读操作  
   2). 当有一个协程获得`读锁 RLock`的时候，所有`写`的协程必须等到所有`读`的协程结束(RUnlock)，才可以获得锁进行写操作  
   3). 当有一个协程获得`写锁 Lock`的时候，所有`读、写`的协程必须等到`写`的协程结束(Unlock), 才可以获得锁进行读、写操作  

## Go里面SQL连接池实现原理
1. 对Mysql使用封装了一下，可以参考 https://github.com/chenguolin/go-mysql
2. sql.DB 是并发安全的，支持多个goroutine同时使用，内部维护一个SQL连接池
   ```
   // DB is a database handle representing a pool of zero or more
   // underlying connections. It's safe for concurrent use by multiple
   // goroutines.
   //
   // The sql package creates and frees connections automatically; it
   // also maintains a free pool of idle connections. If the database has
   // a concept of per-connection state, such state can only be reliably
   // observed within a transaction. Once DB.Begin is called, the
   // returned Tx is bound to a single connection. Once Commit or
   // Rollback is called on the transaction, that transaction's
   // connection is returned to DB's idle connection pool. The pool size
   // can be controlled with SetMaxIdleConnCount.
   type DB struct {
	driver driver.Driver
	dsn    string
	// numClosed is an atomic counter which represents a total number of
	// closed connections. Stmt.openStmt checks it before cleaning closed
	// connections in Stmt.css.
	numClosed uint64

	mu           sync.Mutex // protects following fields
	freeConn     []*driverConn
	connRequests map[uint64]chan connRequest
	nextRequest  uint64 // Next key to use in connRequests.
	numOpen      int    // number of opened and pending open connections
	// Used to signal the need for new connections
	// a goroutine running connectionOpener() reads on this chan and
	// maybeOpenNewConnections sends on the chan (one send per needed connection)
	// It is closed during db.Close(). The close tells the connectionOpener
	// goroutine to exit.
	openerCh        chan struct{}
	closed          bool
	dep             map[finalCloser]depSet
	lastPut         map[*driverConn]string // stacktrace of last conn's put; debug only
	maxIdle         int                    // zero means defaultMaxIdleConns; negative means 0
	maxOpen         int                    // <= 0 means unlimited
	maxLifetime     time.Duration          // maximum amount of time a connection may be reused
	cleanerCh       chan struct{}
	connWaitTimeout time.Duration // time out for wait connection
	connIdleTimeout time.Duration // time out for connection idled
   }
   ```
   支持以下4个方法  
   1). SetMaxOpenConnCount: 设置数据库最大的连接数  
   2). SetMaxIdleConnCount: 设置连接池最大的数量  
   3). SetConnWaitTimeout: 设置连接等待超时时间  
   4). SetConnIdleTimeout: 设置空闲连接超时时间

## Go什么情况下会发生内存泄露
1. Go支持垃圾回收，通常我们不需要关心内存泄漏问题，因为语言运行时(runtime)会定期做GC
2. Go内存泄露的情况: `10次内存泄露，有9次是goroutine泄露`
   + 求子字符串(Substrings)导致的轻微内存泄露
     ```
     var s0 string // package level variable

     func f(s1 string) {
        // 假设 s1 是一个长度为1M 的字符串.
        s0 = s1[:50]
        // 现在, s0 和 s1 共享相同的底层内存块.
        // s1 现在不存活了, 但是 s0 依然存活.
        // 尽管仅有 50 个字节在内存块中,
        // s0 仍旧存活的事实阻止了这 1M 字节的内存块被回收.
     }
     
     使用 strings.Builder 来优化
     ```
   + 求子切片(Subslices)导致的轻微内存泄露
     ```
     var s0 []int
     func g(s1 []int) {
         // 假设 s1 的长度远远大于 30
	 s0 = s1[len(s1)-30:]
     }
     
     与求子串类似, 求子切片也可能导致轻微的内存泄漏
     ```
   + Goroutines 导致的内存泄露: 一个或多个 goroutine 会永远处于阻塞状态, 这将导致这些 goroutine 中使用的许多代码块永远无法进行垃圾收集
     ```
     func k(c <-chan bool) {
         s := make([]int64, 1e6)
	 if <-c { // 如果 c 为 nil, 这里将永远阻塞
	     _ = s
	     // 使用 s, ...
	 }
     }
     ```
3. 怎么发现内存泄露
   + `监控工具`：固定周期对进程的内存占用情况进行采样，数据可视化后，根据内存占用走势（持续上升），很容易发现是否发生内存泄露。
   + `go pprof`：适合没有监控工具的情况，使用Go提供的pprof工具判断是否发生内存泄露
4. 什么是goroutine泄露: 如果你启动了1个goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是goroutine泄露。goroutine泄露的本质是channel阻塞，无法继续向下执行，导致此goroutine关联的内存都无法释放，进一步造成内存泄露。
5. goroutine泄露怎么导致内存泄露: 每个goroutine占用`2KB`内存，泄露100w goroutine至少泄露`2KB * 1000000 = 2GB`内存
   + goroutine执行过程中还存在一些变量，如果这些变量指向堆内存中的内存，GC会认为这些内存仍在使用，不会对其进行回收，这些内存谁都无法使用，造成了内存泄露。
   + goroutine本身的栈所占用的空间造成内存泄露
6. 为避免goroutine泄露造成内存泄露，启动goroutine前要思考清楚
   + goroutine如何退出？
   + 是否会有阻塞造成无法退出？如果有，那么这个路径是否会创建大量的goroutine？
7. goroutine泄露的例子
   ```
   func main() {
       ...
       outCh := make(chan int)
       
       // goroutine
       go func() {
           if false {
               <-outCh  //永远读不到
           }
           select {}  //无限阻塞
       }()

       // 每秒起100个goroutine，goroutine会阻塞，不释放内存
       tick := time.Tick(time.Second / 100)
       i := 0
       for range tick {
           i++
           fmt.Println(i)
           alloc1(outCh)
       }
      }

   func alloc1(outCh chan<- int) {
       go alloc2(outCh)
   }

   func alloc2(outCh chan<- int) {
       func() {
           defer fmt.Println("alloc-fm exit")
           // 分配内存，假用一下
           buf := make([]byte, 1024*1024*10)
           _ = len(buf)
           fmt.Println("alloc done")

           outCh <- 0 // 发送到outCh，但是没有接收操作，会一直阻塞，所以会导致当前goroutine一直无法结束，只能等程序退出才结束
       }()
   }
   ```

## Go怎么实现协程完美退出
1. 使用channel阻塞的原理来实现，主协程必须等所有协程结束之后才能结束，这样就可以保证协程完美退出

## Go为什么高并发那么好
1. Go的两大核心技术: goroutine 和 channel
   + goroutine: 语言级别的调度，用户级调度协程
   + channel: 高并发之间的数据通信工具
2. 主要的原因是 Go的调度器能够支持单个系统线程上运行10万级别的goroutine，这极大的提高了程序的并发能力

## interface怎么理解
Go 没有类和继承，因此如果我们想要实现类似C++的多态，就需要借助interface。基类就相当于是一个interface，定义好所有的方法。不同子类型只需要各种实现这些方法就相当于是继承了这个基类，从而实现多态

1. interface 是一种类型
   ```
   type I interface {
       ...
   }
   ```
   如果一个类型实现了一个 interface 中所有方法，我们说类型实现了该 interface，所以所有类型都实现了 empty interface，因为任何一种类型至少实现了 0 个方法。go 没有显式的关键字用来实现 interface，只需要实现 interface 包含的方法即可。
2. 如何判断 interface 变量存储的是哪种类型
   一个 interface 被多种类型实现时，有时候我们需要区分 interface 的变量究竟存储哪种类型的值，go 可以使用 comma, ok 的形式做区分 value, ok := em.(T)：`em 是 interface 类型的变量，T代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T`。
3. 空的 interface
   interface{} 是一个空的 interface 类型，一个类型如果实现了一个 interface 的所有方法就说该类型实现了这个 interface，空的 interface 没有方法，所以可以认为所有的类型都实现了 interface{}。  
   `如果定义一个函数参数是 interface{} 类型，这个函数应该可以接受任何类型作为它的参数。`

## map是并发安全的吗
1. Map 不是并发安全的，即使我们只是增减其中的Key
2. 并发条件下我们需要使用 sync.RWMutex来保证某一时刻只能有一个协程操作 Map

## 数据经过channel传递的时候会被复制 这个复制是浅拷贝还是深拷贝
1. 浅拷贝
2. 在 Go 语言中并不存在深拷贝，除非我们自己实现

## select语句中发现某个channel已经关闭 如何屏蔽掉它的分支
1. 直接把`nil`赋值给这个channel对应的变量即可，这样对于这个通道的发送和接收操作都会阻塞

## select与for一起使用的时候 如何退出外层循环
1. 使用 goto 和 label 结合
2. 使用 break 和 label 结合

## struct{}代表了什么有什么用处
1. struct{}表示空的结构体，这样的类型既不包括任何字段也没有任何方法，该类型所占的空间几乎可以忽略不计
2. 通常使用struct{}做为占位符来使用，例如使用map[string]struct{} 比 map[string]bool 占用更少的空间

## 如何限制goroutine的数量
1. https://github.com/chenguolin/go-common/tree/master/waitgroup 可以限制最大的goroutine数量
2. sizedwaitgroup实现的原理是在sync.WaitGroup基础上加了一个 channel，通过channel的size满了之后会阻塞发送操作来实现最大的goroutine数量
   ```
   // Add increments the internal WaitGroup counter.
   func (s *SizedWaitGroup) Add() {
	s.current <- struct{}{}:       //如果channel buffer满了，这里的发送操作会阻塞，直到有goroutine结束
	return nil
   }
   
   // Done decrements the SizedWaitGroup counter.
   func (s *SizedWaitGroup) Done() {
	<-s.current
	s.wg.Done()
   }

   // Wait blocks until the SizedWaitGroup counter is zero.
   func (s *SizedWaitGroup) Wait() {
	s.wg.Wait()
   }
   ```
3. 可以使用分批启用goroutine方法，`先统一Add，再并发Done，最后Wait`
   ```
   total := 100
   batch := 10
   var wg sync.WaitGroup
   for i = 1; i <= total; i = i+batch{
       wg.Add(batch)
       for j = 1; j <= batch; j++ {
           go addNum(wg)   //内部执行完成调用 wg.Done()
       }
       wg.Wait()
   }
   ```

## Context值在传递撤销信号的时候是广度优先还是深度优先
1. 它是深度优先，直接分支的产生时间越早那么其中的所有子节点就会越早接收到信号

## Golang垃圾回收算法
参考 https://chenguolin.github.io/2018/07/01/Go-2-Go%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/

## Golang里的逃逸分析是什么，怎么避免内存逃逸
1. 逃逸分析在编译阶段完成，逃逸分析目的是决定内分配地址是栈还是堆
2. 栈上分配内存比在堆中分配内存有更高的效率，栈上分配的内存不需要GC处理，函数返回后就被自动回收
3. 堆上分配的内存使用完毕会交给GC处理

https://driverzhang.github.io/post/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/

## Golang 的 GC 触发时机是什么
1. gcTriggerHeap: 当前分配的内存达到一定值（动态计算）就触发GC （这个阈值会随着每次内存使用变大而逐渐增大（如初始阈值是 10MB 则下一次就是 20MB，再下一次就成为了 40MB…）
2. gcTriggerTime: 当一定时间（2分钟）没有执行过GC就触发GC （如果长时 间没有触发 gc go 会主动触发一次（2min））
3. gcTriggerCycle: 要求启动新一轮的GC, 已启动则跳过, 手动触发GC的runtime.GC()会使用这个条件

https://studygolang.com/articles/17432  
http://ngudream.com/2016/08/22/golang-gc/  

高峰时内存使用量上去后，除非持续申请内存，靠阈值触发 gc 已经基本不可能，而是要等最多 2min 主动 gc 开始才能触发 gc。第二个原因是 go 语言在向系统交还内存时只是告诉系统这些内存不需要使用了，可以回收；同时操作系统会采取 “拖延症” 策略，并不是立即回收，而是等 到系统内存紧张时才会开始回收这样该程序又重新申请内存时就可以获得极快的分配速度。

## 为什么选用Gin做为HTTP API Service框架
1. Golang web框架比较有名包括以下几种: gin、beego、echo、iris等
2. 为什么选择Gin: Gin是轻量级框架，如果只需要实现api，微服务等，使用轻量级框架比较合适
   + 性能极高: 基于 Radix 树的路由，小内存占用，没有反射，可预测的 API 性能
   + 扩展性好: 能够快速写出各种中间件
   + 支持中间件: 传入的 HTTP 请求可以由一系列中间件和最终操作来处理
   + Crash 处理: Gin 可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它。这样，你的服务将始终可用
   + JSON 验证: Gin 可以解析并验证请求的 JSON，例如检查所需值的存在
   + 路由组: 更好地组织路由。是否需要授权，不同的 API 版本…… 此外，这些组可以无限制地嵌套而不会降低性能
   + 错误管理: Gin 提供了一种方便的方法来收集 HTTP 请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送
   + 内置渲染: Gin 为 JSON，XML 和 HTML 渲染提供了易于使用的 API
   
## 对比一下Golang和Java的GC
1. Golang采用三色标记清除法
2. Java采用分代法

