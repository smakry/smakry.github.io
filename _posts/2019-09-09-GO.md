---
layout: post
title: 'Golang'
date: 2019-09-09
author: smakry
tags: GO 阅读笔记
---

> 简洁、快速、安全

> 并行、有趣、开源
 
> 内存管理、数组安全、编译迅速

## Go笔记

Go强类型化的语言，具有垃圾回收机制，并显示支持并编程，Go原生地支持Unicode，可以处理所有国家的语言  
<https://github.com/golang/go/wiki/NonEnglish>  

- GOPATH目录可以是任意的，唯一的要求是`不能是你安装Go的目录`  
<https://go-zh.org/doc/code.html>  

- linux下git  
<https://blog.csdn.net/qq_42303254/article/details/89230332>

go游戏框架  
<https://github.com/liangdas/mqant/wiki>

- import “()”里的导入顺序最终会被gofmt工具按照字母顺序表进行排序  
- range产生键值对，当不使用其中的键或者值要用"_"下划线表示（空标识符），Go不允许存在无用的临时变量  
- range的for循环迭代顺序是随机（无序的）  
- 格式化类型verb（动词），下表不完整还有更多  
verb | 描述
%d 		 |十进制整数  
%x,%o,%b |十六进制，八进制，二进制数  
%f,%g,%e |浮点数：如3.141593，3.141592653589793，3.141593e+00  
%t		 |布尔型：true或者false  
%c		 |字符（Unicode码点）  
%s		 |字符串  
%q		 |带引号字符串（如"ABC"）或者字符（如'C'）  
%v		 |内置格式的任何值  
%T		 |任何值的类型  
%%		 |百分号本身（无操作数）  

-go关键字
break	|default	|func	|interface	|select	  
case	|defer		|go		|map		|struct  
chan	|else		|goto	|package	|switch  
const	|fallthrough|if		|range		|type  
continue|for		|import	|return		|var  

- 内置的预声明的常量、类型和函数  
常量：true	false	iota	nil  

类型：（byte=uint8，rune=int32）  
int		|int8	|int16		|int32	|int64  
uint	|uint8	|uint16		|uint32	|uint64	|uintptr  
float32	|float64|complex64	|complex128  
bool	|byte	|rune		|string	|error  

函数：  
make	|len	|cap	|**new**	|append	|copy	|close	|delete	  
complex	|real	|imag	|panic	|recover  

- 包里函数外的全局函数，`大写开头的函数其它包可见`（导出的，type类型同规则），包名总是小写字母组成  
- 函数调用可在声明之前，函数和其它`包级别`的实体可以以`任意次序`声明（变量类似）  

```go
//包级别
var a = b + c //包级别的这种方式是正确的，最后a = 3
var b = 1
var c = 2

```  
- map是一个使用make创建的数据结构的`引用`（变量别名）  
- GO有escape analysis，在编译期，它会分析你的变量是否在函数执行完毕那一刻，程序有没有可能有别的对象引用到它（所谓逃逸，`逃逸的在堆上分配`），如果没有，那这个变量就可以在栈上分配，完全不经过gc。如果它已经逃逸了，那什么时候gc就由不得你了。(go build 加上-gcflags='-m'会显示escape内容)<https://blog.csdn.net/weixin_42117918/article/details/82024667>
    - 对于`包一级声明的变量`来说，它们的`生命周期和整个程序的运行周期一致`；
    - 而`局部变量`生命周期则是`动态`的：每次从创建一个新变量的声明语句开始，直到该变量`不再被引用为止`(不可访问)，然后变量的存储空间`可能`被回收。
- 字符串变量声明方式  
- 初始值对于类型的零值（数值是0；布尔值是false；字符串是""；对于接口和引用类型（slice、指针、map、通道、函数）是nil；对于像数组或结构体这样的符合类型，零值是其所有元素或成员的零值），go里面不存在未初始化变量    
- doc.go文件对包的文档注释

```go
s := "" //常用于函数内局部变量（常用）  
var s string //常用于包内，默认初始化""（常用）
var s = "" //由初值判定类型
var s string = "" //显示变量类型
```

- func (t Time) Second() int{} //Time类型的一个方法Second()  
- 当一个goroutine试图在一个通道上进行发送或者接收操作时，它会`阻塞`，直到另一个goruntine试图进行接收或者发送操作才传递值（读写锁？）  
- switch中case从上到下推演，但是default可以放到任何位置  
- go`指针不支持算术运算`  
- 额外的bool结果：  
v,ok = m[key] //map查询  
v,ok = x.(T) //类型断言  
v,ok = <-ch //通道接收  

- T(x)`将值x转成T类型`，T类型与x具有相同的底层类型或者二者都指向相同底层类型的未命名指针则二者可以转换；通过==和<等比较操作符，命名类型（type的类型）的值可以与其相同类型的值或者底层类型相同的未命名类型的值相比较，但是不同命名类型的值不能直接比较：  

```go
type TypeA float64
type TypeB float64

var a TypeA
var b TypeB
var c TypeA
fmt.Println(a == b) //编译错误，不同的命名类型
fmt.Println(a == 0) //true（a类型转换int(a)，底层类型变成int与0的底层类型相同）
fmt.Println(a == c) //true相同的命名类型
```  

- 包初始化？？？
- 作用域问题（同样规则运用于switch）：  

```go
func f()int{
    return 15;
}

func main(){
    if x := f();x < 10 {
        fmt.Printf("xx")
    } else if x < 15 { //x也在作用域内

        fmt.Printf("%d",x)
    } else {
        fmt.Printf("world:%d",x)
    }

    fmt.Printf("world:%d",x) //此处x是未定义，不在作用域内
}

```

- int不等同于int32，uint不等同uint32（在特定平台是相等的，或者是该平台上的运算效率最高的值，但不同硬件平台或者不同编译器大小是不一定的）
- go中取模余数的正负号总是与被除数一致（-5%3和-5%-3都是-2）  
- &^操作符，按位将右边二进制1的位在左边出现的置0   
- 十进制下，float32有效小数大约6位，float64小数大约15位。绝大多数情况下应优先选用float64，float32能精确表示的正整数范围有限：  

```go
var f float32 = 16777211
fmt.Println(f == f + 1)  //结果false

var f2 float32 = 1 << 24 //只能精确到1<<24
fmt.Println(f2 == f2 + 1) //结果true  

nan := math.NaN()
fmt.Println(nan == nan,nan < nan,nan > nan) //"false false false"比较总是不成立
```

- go的bool值只有true和false，0和1不能隐式转成false和true，反之也不行  
- 字符串可以追加`不能修改`如 s := "left foot" 可以 s += ",right foot" 但s[0] = 'L'编译错误。不能重赋值，代表原始串的字串可以共用原始串的内存地址（不需要重新分配内存） 
- Printf格式化字符含多个%谓词，原本要求提供相应数量的操作数，而%后的副词[1]告知Printf重复使用第1个操作数，其次副词#告知Printf输出相应的前缀  

```go
o := 0666
fmt.Printf("%d %#o %#[2]x\n",o,o) //重复使用第2个操作数
```  

- go源文件总是UTF-8编码（变长编码）。\uhhhh表示16位码点值，\Uhhhhhhhh表示32位码点值，每个h表示一个十六进制数字。码点值`小于256`的可用单个十六进制数转义如'A'写成'\x41'`更高的需要用\u或\U`转义，\x会存在不合法的文字符号。UTF-8解码器读入一个不合理的字节，无论显示调用utf8.DecodeRuneInString还是range循环内隐式读取，都会产生一个专门的Unicode字符'\uFFFD',输出类似�，表示上游处理文字编码存在瑕疵。

```go
	s := "Hello, 世界"

	fmt.Println(len(s))
	fmt.Println(utf8.RuneCountInString(s))
	
	for i := 0; i < len(s);{
		r,size := utf8.DecodeRuneInString(s[i:])
		fmt.Printf("%d\t%c\n",i,r)
		i += size //索引需根据具体的字符占用字节计算
	}
/*输出结果
13
9
0	H
1	e
2	l
3	l
4	o
5	,
6	 
7	世
10	界
*/

	for i,r := range s {
		fmt.Printf("%d\t%q\t%d\n",i,r,r)
	}
/*输出结果
0	'H'	72
1	'e'	101
2	'l'	108
3	'l'	108
4	'o'	111
5	','	44
6	' '	32
7	'世'	19990
10	'界'	30028 //返回的索引直接字符的起始索引
*/

```

- const iota = 0 // Untyped int  

```go
const(
	_ = 1  << (10 * iota)
	KiB // 1024 (1 << (10 * 1))
	MiB // 1048576
	GiB // 1073741824
	TiB // 1099511627776
	PiB // 1125899906842624
	EiB // 1152921504606846976
	ZiB // 1180591620717411303424
	YiB // 1208925819614629174706176
)
```

- q := [...]int{1,2,3}省略号“...”出现在数组长度的位置，表示输出长度由初始化的元素个数决定    
- r := [...]int{9:-1} 定义10个数据，最后一个数据的值是-1，其余默认值0。由最大的index决定
- 数组是可以比较（数据类型跟元素个数一致的情况下才能比较，比较的是元素值。不同类型或不同元素个数比较会编译错误）  
- init执行顺序根据import然后再当前包按顺序（当前包可以有多个init）  
- tree dir (linux查看dir的目录树，省略dir即当前目录)

### 变量
- `:=`省略var，左侧没有`声明新的变量`，产生编译错误（常用于初始化声明）

```go
    var intVal int
    intVal := 1 //编译错误intVal不是新的变量
	g,h := 123,"test" //只能在`函数体中`出现
````

- 因式分解关键字写法用于声明全局变量

```go
var(
	a int
	b bool
)
````

- 局部变量声明未使用编译错误，全局变量声明未使用是允许的  


### 常量
- iota常量（可被编译器修改的常量），`const出现iota重置为0`。const`语句块中每行+1`

```go
package main

import "fmt"
const (
    i=1<<iota
    j=3<<iota
    k
    l
)

func main() {
    fmt.Println("i=",i)
    fmt.Println("j=",j)
    fmt.Println("k=",k)
    fmt.Println("l=",l)
}

输出结果：
i=1
j=6
k=12
l=24

//k=3<<iota(1+1) l=3<<iota(1+1+1)
```

### 运算
- go`不支持前++`，i++是一种语句，而非表达式（不同于C族语言，`j = i++ 是不合法的`）

### select语句（随机版switch）
- select随机一个可运行的case，可运行退出
- 若无default子句，select会阻塞，循环检测条件直到满足才退出循环

### Go默认的`值传递`，调用过程不会影响到实际参数

### Slice(切片)，即可扩容“动态数组”
````go
var slice []int = make([]int,10) //定义长度10的切片
s := slice[startIndex:endIndex] //复制切片从指定的位置，默认值切片起止位置
````

### Map(集合)

var myMap map[int]string //声明变量，若`无初始化是nil` map不能存放键值对（slice切片也是一样） 
myMap = make(map[int]string) //创建集合，此时才能修改map

### Interface接口（方法的集合）
- 接口`只能定义`方法，具体的由实现接口的类提供
- 定义对象`必须实现`的成员，定义方式同时结构体
- 接口不能直接实例化

### 错误处理
- 实现error接口的错误处理

### 并发、channel
- Go支持语言并发，通过go关键字开启goroutine
- goroutine轻量级线程，调度由Golang运行时进行管理
- goroutine两个之间传递通过channel（通道）