---
layout: post
title: 'Golang'
date: 2019-09-09
author: smakry
tags: GO 阅读笔记
---

> 简洁、快速、安全

> 并行、有趣、开源
 
> 内存管理、数组安全、编译迅速

## Go笔记

Go强类型化的语言，具有垃圾回收机制，并显示支持并发编程，Go原生地支持Unicode，可以处理所有国家的语言。Go静态类型语言，类型仅仅是一个编译时的概念。  
<https://github.com/golang/go/wiki/NonEnglish>  

- GOPATH目录可以是任意的，唯一的要求是`不能是你安装Go的目录`  
<https://go-zh.org/doc/code.html>  

- linux下git  
<https://blog.csdn.net/qq_42303254/article/details/89230332>

go游戏框架  
<https://github.com/liangdas/mqant/wiki>

- import “()”里的执行顺序按照导入的先后顺序  
- `同包`下的`不同 go 文件`，按照文件名“从小到大”排序顺序执行  
- 一个包被其它多个包import，但只能被初始化一次  
- range产生键值对，当不使用其中的键或者值要用"_"下划线表示（空标识符），Go不允许存在无用的临时变量  
- range的for循环迭代顺序是随机（无序的）  
- 格式化类型verb（动词），下表不完整还有更多  
verb | 描述
%d 		 |十进制整数  
%x,%o,%b |十六进制，八进制，二进制数  
%f,%g,%e |浮点数：如3.141593，3.141592653589793，3.141593e+00  
%t		 |布尔型：true或者false  
%c		 |字符（Unicode码点）  V
%s		 |字符串  
%q		 |带引号字符串（如"ABC"）或者字符（如'C'）  
%v		 |内置格式的任何值  
%T		 |任何值的类型  
%p		 |指针，十六进制表示，前缀0x  
%%		 |百分号本身（无操作数）  

-go关键字
break	|default	|func	|interface	|select	  
case	|defer		|go		|map		|struct  
chan	|else		|goto	|package	|switch  
const	|fallthrough|if		|range		|type  
continue|for		|import	|return		|var  

- 内置的预声明的常量、类型和函数  
常量：true	false	iota	nil  

类型：（byte=uint8，rune=int32）  
int		|int8	|int16		|int32	|int64  
uint	|uint8	|uint16		|uint32	|uint64	|uintptr  
float32	|float64|complex64	|complex128  
bool	|byte	|rune		|string	|error  

函数：  
make	|len	|cap	|**new**	|append	|copy	|close	|delete	  
complex	|real	|imag	|panic	|recover  

- 包里函数外的全局函数，`大写开头的函数其它包可见`（导出的，type类型同规则），包名总是小写字母组成  
- 函数调用可在声明之前，函数和其它`包级别`的实体可以以`任意次序`声明（变量类似）  

```go
//包级别
var a = b + c //包级别的这种方式是正确的，最后a = 3
var b = 1
var c = 2

```  
- map是一个使用make创建的数据结构的`引用`（变量别名）  
- GO有escape analysis，在编译期，它会分析你的变量是否在函数执行完毕那一刻，程序有没有可能有别的对象引用到它（所谓逃逸，`逃逸的在堆上分配`），如果没有，那这个变量就可以在栈上分配，完全不经过gc。如果它已经逃逸了，那什么时候gc就由不得你了。(go build 加上-gcflags='-m'会显示escape内容)<https://blog.csdn.net/weixin_42117918/article/details/82024667>
    - 对于`包一级声明的变量`来说，它们的`生命周期和整个程序的运行周期一致`；
    - 而`局部变量`生命周期则是`动态`的：每次从创建一个新变量的声明语句开始，直到该变量`不再被引用为止`(不可访问)，然后变量的存储空间`可能`被回收。
- 字符串变量声明方式  
- 初始值对于类型的零值（数值是0；布尔值是false；字符串是""；对于接口和引用类型（slice、指针、map、通道、函数）是nil；对于像数组或结构体这样的符合类型，零值是其所有元素或成员的零值），go里面不存在未初始化变量    
- doc.go文件对包的文档注释

```go
s := "" //常用于函数内局部变量（常用）  
var s string //常用于包内，默认初始化""（常用）
var s = "" //由初值判定类型
var s string = "" //显示变量类型
```

- func (t Time) Second() int{} //Time类型的一个方法Second()  
- 当一个goroutine试图在一个通道上进行发送或者接收操作时，它会`阻塞`，直到另一个goruntine试图进行接收或者发送操作才传递值（读写锁？）  
- switch中case从上到下推演，但是default可以放到任何位置  
- go`指针不支持算术运算`  
- 额外的bool结果：  
v,ok = m[key] //map查询  
v,ok = x.(T) //类型断言  
v,ok = <-ch //通道接收  

- T(x)`将值x转成T类型`，T类型与x具有相同的底层类型或者二者都指向相同底层类型的未命名指针则二者可以转换；通过==和<等
- 操作符，命名类型（type的类型）的值可以与其相同类型的值或者底层类型相同的未命名类型的值相比较，但是不同命名类型的值不能直接比较：  

```go
type TypeA float64
type TypeB float64

var a TypeA
var b TypeB
var c TypeA
fmt.Println(a == b) //编译错误，不同的命名类型
fmt.Println(a == 0) //true（a类型转换int(a)，底层类型变成int与0的底层类型相同）
fmt.Println(a == c) //true相同的命名类型
```  

- 包初始化？？？
- 作用域问题（同样规则运用于switch）：  

```go
func f()int{
    return 15;
}

func main(){
    if x := f();x < 10 {
        fmt.Printf("xx")
    } else if x < 15 { //x也在作用域内

        fmt.Printf("%d",x)
    } else {
        fmt.Printf("world:%d",x)
    }

    fmt.Printf("world:%d",x) //此处x是未定义，不在作用域内
}

```

- int不等同于int32，uint不等同uint32（在特定平台是相等的，或者是该平台上的运算效率最高的值，但不同硬件平台或者不同编译器大小是不一定的）
- go中取模余数的正负号总是与被除数一致（-5%3和-5%-3都是-2）  
- &^操作符，按位将右边二进制1的位在左边出现的置0   
- 十进制下，float32有效小数大约6位，float64小数大约15位。绝大多数情况下应优先选用float64（其它语言的double？），float32能精确表示的正整数范围有限：  

```go
var f float32 = 16777211
fmt.Println(f == f + 1)  //结果false

var f2 float32 = 1 << 24 //只能精确到1<<24
fmt.Println(f2 == f2 + 1) //结果true  

nan := math.NaN()
fmt.Println(nan == nan,nan < nan,nan > nan) //"false false false"比较总是不成立
```

- go的bool值只有true和false，0和1不能隐式转成false和true，反之也不行  
- 字符串可以追加`不能修改`如 s := "left foot" 可以 s += ",right foot" 但s[0] = 'L'编译错误。不能重赋值，代表原始串的字串可以共用原始串的内存地址（不需要重新分配内存） 
- 字符串使用下标索引获取的是编码对应的值（不一定是ascii码，要看具体的字符，但`rune可存下所有`）   
- Printf格式化字符含多个%谓词，原本要求提供相应数量的操作数，而%后的副词[1]告知Printf重复使用第1个操作数，其次副词#告知Printf输出相应的前缀  

```go
o := 0666
fmt.Printf("%d %#o %#[2]x\n",o,o) //重复使用第2个操作数
```  

- go源文件总是UTF-8编码（变长编码）。\uhhhh表示16位码点值，\Uhhhhhhhh表示32位码点值，每个h表示一个十六进制数字。码点值`小于256`的可用单个十六进制数转义如'A'写成'\x41'`更高的需要用\u或\U`转义，\x会存在不合法的文字符号。UTF-8解码器读入一个不合理的字节，无论显示调用utf8.DecodeRuneInString还是range循环内隐式读取，都会产生一个专门的Unicode字符'\uFFFD',输出类似�，表示上游处理文字编码存在瑕疵。

```go
	s := "Hello, 世界"

	fmt.Println(len(s))
	fmt.Println(utf8.RuneCountInString(s))
	
	for i := 0; i < len(s);{
		r,size := utf8.DecodeRuneInString(s[i:])
		fmt.Printf("%d\t%c\n",i,r)
		i += size //索引需根据具体的字符占用字节计算
	}
/*输出结果
13
9
0	H
1	e
2	l
3	l
4	o
5	,
6	 
7	世
10	界
*/

	for i,r := range s {
		fmt.Printf("%d\t%q\t%d\n",i,r,r)
	}
/*输出结果
0	'H'	72
1	'e'	101
2	'l'	108
3	'l'	108
4	'o'	111
5	','	44
6	' '	32
7	'世'	19990
10	'界'	30028 //返回的索引直接字符的起始索引（注意不是连续）
*/

	a := "aaa时空裂缝就阿卡"
	b := []rune(a)
	fmt.Println(string(b[3])) //输出：时
```

- const iota = 0 // Untyped int  

```go
const(
	_ = 1  << (10 * iota)
	KiB // 1024 (1 << (10 * 1))
	MiB // 1048576
	GiB // 1073741824
	TiB // 1099511627776
	PiB // 1125899906842624
	EiB // 1152921504606846976
	ZiB // 1180591620717411303424
	YiB // 1208925819614629174706176
)
```

- init执行顺序根据import然后再当前包按顺序（当前包可以有多个init）  
- tree dir (linux查看dir的目录树，省略dir即当前目录)  
- 函数调用，参数都会创建一个副本（不同于其它语言的引用），这样就会拷贝一次值（`指针、slice、map函数和通道channel也是值拷贝`，只是包含了引用类型或者是可以通过包含的类型修改实参值。例如slice包含指向底层数组的指针，这就能改变到底层数组）
- q := [...]int{1,2,3}省略号“...”出现在数组长度的位置，表示输出长度由初始化的元素个数决定    
- r := [...]int{9:-1} 定义10个数据，最后一个数据的值是-1，其余默认值0。由最大的index决定
- 二维数组同其它需指定第2维度长度 
- 数组是可以比较（`数据类型`跟`元素个数`一致的情况下才能比较，比较的是元素值。不同类型或不同元素个数比较会编译错误）  
- 切片slice有3个属性指针、长度和容量。（切片，即可视作是数组的一个`子片的引用`）
    - 指针是指向该切片的第1个元素（`并非底层的数组的首元素`）
    - 长度是指slice中元素个数，不能超过slice的容量，内置函数len获取
    - 容量即切片的起始位置到底层数组的最后一个元素间元素个数，内置函数cap获取
    - s := []int{0,1,2}与 s := [...]int{0,1,2}注意二者区别`[]表示切片`，`[...]表示的是数组`类型不同；`切片不能通过==等来比较`，标准库有bytes.Equal来比较字节切片（[]byte）,其余的比较需自己实现   
    - 判断slice是不是为空不能用== nil因为 s = []int{}用== nil返回是false但实际是空，需用len() == 0判定  
    - make([]T,len,cap) 和make([]T,cap)[:len]二者等价（注意cap位置）  
    - append方式类似c++中verctor的动态扩容方式（`内存地址变化了`）  
    - s1 = append(s1[0:3], s2[:]...) //s1保留0 ~ 2这3个数据，`剩余数据全部弃用`，然后追加s2的所有元素  
    - input[low:high:max]，其中low 和 high 和一般切片表达式的用法一样，那么运算后的切片cap为：max — low。
        完整切片巧妙用法：   
        p := append(t[:0:0], t...)  

        相当于：
        p := make([]int,len(t))
        copy(p,t)

```go
arr := [...]string{"Sunday","Monday","Tuesday","Wednesday","Thursday","Firday","Saturday","",""}

work := arr[1:5]

fmt.Println(work[0],len(work),cap(work))
fmt.Printf("%T\n",work)

/*输出
Monday 4 8
[]string
*/

//上面的基础
day := work[:10] //day切片引用从work切片的第1个元素"Monday"后10个，报错超出了work切片的容量8（可以理解原始的容量不足以作为day的引用）

fmt.Println(len(day),cap(day)) //报错
```


- slice作为函数参数是值传递,但可通过切片的底层数组地址进行修改原始数组，但当切片容量长度发生变化就有差别（修改函数外的切片，可通过返回新的切片赋值或者传递指针） 

```go
func main(){
    s1 := []int{1,2,3,4,5,6,7}

	s1 = append(s1[:3],s1[4:]...) //切片s1重新赋值只有原始切片的6个长度（注意重赋值部分）
	fmt.Printf("%d,%d,%d,%p\n",s1,len(s1),cap(s1),s1) //[1 2 3 5 6 7],6,7,0xc00001e080
}

```

```go
func test(slice []int) {
    slice = append(slice[:3],slice[4:]...) //未超出底层数组的长度，没有重新内存分配
}

func main(){
    s1 := []int{1,2,3,4,5,6,7}

    test(s1) //test没有重新分配内存，修改到了原始数组，
			//但是s1在test之外并没有变化，还是指向原始的切片,所以切片还是长度7，2个元素7
    fmt.Printf("%d,%d,%d,%p\n",s1,len(s1),cap(s1),s1) //[1 2 3 5 6 7 7],7,7,0xc00001e080
}

```  

```go
func test(slice []int) {
    slice = append(slice[:3],slice[1:]...) //超出底层数组的长度，重新内存分配
}

func main(){
    s1 := []int{1,2,3,4,5,6,7}

    test(s1) //test重新分配内存，没有修改到了原始数组，
			//但是s1在test之外并没有变化，还是指向原始的切片,所以切片还是长度7
    fmt.Printf("%d,%d,%d,%p\n",s1,len(s1),cap(s1),s1) //[1 2 3 4 5 6 7],7,7,0xc00001e080

}

```

- map
    - map的`键类型必须是可以通过操作符==来进行比较的数据类型`，虽然浮点型可以，但是浮点存在数据有效范围如float32只能精确到1<<24。
    - map中ages["bob"] = ages["bob"] + 1 //当键bob不在map中，这是安全的，`键不存在查找返回的是类型的零值`
    - map`元素`不是一个变量（map类型本身是一个变量），不可以获取它的地址如 _ = &ages["bob"] //编译错误  
    - map中元素迭代是顺序是随机的，取决于散列算法，若需要有序迭代，需通过排序key
    - delete(map, 键) //键删除方式   


```go
var graph = make(map[string]map[string]bool) //map的元素是map

func addEdge(from,to string) {
    edges := graph[from]
    if edges == nil {
        edges = make(map[string]bool)
        graph[from] = edges
    }
    edges[to] = true
}

func hasEdge(from,to string) bool {
    return graph[from][to] //当from跟to都不存在的时候，这个调用依然是安全的（键不存在查找返回的是类型零值）
}

fmt.Printf("%T,%[1]q,%T",graph["sdf"],graph["sdf"]["ssss"]) //结果：map[string]bool,map[],bool

```

- linux结束符ctrl + d

- 结构体
    - 结构体是否能比较取决于结构体成员变量是否都能够比较
    - 结构体的匿名成员变量（只需要指定变量类型，不需要显示的指定变量名称），访问成员时可以直接通过一级的索引访问（匿名看做把成员变量的成员变量全部提升一级到结构体中，`展开`）；匿名成员有隐式的名字所以`不能同时存在2个相同类型的匿名变量`（冲突了都指向同一个）  
    - 结构体类型可导出，结构体匿名成员若是不可导出的（小写开头），那么引用包不能通过.成员变量的方式访问（因为成员是不可导出），但是可通过匿名的方式访问（因为结构体本身是可导出的，展开就能访问到）

```go
type Point struct{
	X,Y int
}

type Circle struct{
	Point //只指定了Point类型没有实际的名称，此时就相当于展开Point类型,但也可以通过类型访问
	Radius int
}

var c Circle
c.X = 10 //匿名展开
c.Point.X = 10 //匿名未展开，2种方式是一致的
```

- vim多行注释，查找替换  
:20,30 s/^/#/g 第20到30行用 # 注释掉。  
:20,30 s/^#//g 取消注释  
用 . 表示当前行。  
:.,30 s/^/#/g  
/string （sting为查找对象）正向查找  
？string 反向查找  
：m,n> 向右移动一个tab  
：m,n< 向左移动一个tab  
vim \~/.vimrc  当前用户vim配置  
vim /etc/vim/vimrc 系统vim配置  

- json
    - func Marshal(v interface{}) ([]byte, error) //go类型转成json
    - func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) //按照格式转成json
    - func Unmarshal(data []byte, v interface{}) error //json转成go类型  
    - `成员标签定义`（转成json后，成员对应转化）  

```go
package main

import(
    "fmt"
    "encoding/json"
    "log"
)

type Movie struct {
    Title   string
    Year    int     `json:"released,string"` //成员标签定义，Year字段用released替换，且类型替换为string
    Color   bool    `json:"color,omitempty"` //成员标签定义，Color字段用color替换，omitempty表示bool类型可以忽略空
    Actors  []string
}

func main(){
    var movies = []Movie{
        {Title:"t1",Year:1854,Color:false,
            Actors:[]string{"Husdf","fsdfs"}},
        {Title:"t2",Year:1842,Color:true,
            Actors:[]string{"Husdf","fsdfs"}},
        {Title:"t3",Year:1842,Color:false,
            Actors:[]string{"Husdf","fsdfs"}},
    }

    data,err := json.MarshalIndent(movies,"","  ")
    if err != nil {
        log.Fatalf("sfderro")
    }

    fmt.Printf("%s\n",data)
}

```

- 格式化输出文本模板和HTML模板（以下是文本模板，HTML同样是格式化为可解析html的）,html模板可用来防止注入攻击（按照格式化生成，防止重新解析）

```go
package main

import(
    "fmt"
    "encoding/json"
    "net/http"
    "net/url"
    "strings"
    "time"
    "text/template"
    "log"
    "os"
)

const IssuesURL = "https://api.github.com/search/issues"

//注意printf后有空格，使用的是“`”不是单引号
const temp1 = `{{.TotalCount}} issues:
{{range.Items}}------------------------
Number: {{.Number}}
User:   {{.User.Login}}
Title:  {{.Title | printf "%.64s"}}
Age:    {{.CreatedAt | daysAgo}} days
{{end}}`

var mytmp = template.Must(template.New("report").Funcs(template.FuncMap{"daysAgo" : daysAgo}).Parse(temp1))

type IssuesSearchResult struct {
    TotalCount  int `json:"total_count"`
    Items       []*Issue
}

type Issue struct {
    Number      int
    HTMLURL     string `json:"html_url"`
    Title       string
    State       string
    User        *User
    CreatedAt   time.Time `json:"created_at"`
    Body        string
}

type User struct {
    Login   string
    HTMLURL string `json:"html_url"`
}

func daysAgo(t time.Time) int {
    return int(time.Since(t).Hours() / 24)
}

func SearchIssues(terms []string)(*IssuesSearchResult,error) {
    q := url.QueryEscape(strings.Join(terms," "))
    resp,err := http.Get(IssuesURL + "?q=" + q)
    if err != nil {
        return nil,err
    }

    if resp.StatusCode != http.StatusOK {
        resp.Body.Close()
        return nil,fmt.Errorf("search query failed:%s",resp.Status)
    }

    var result IssuesSearchResult
    if err := json.NewDecoder(resp.Body).Decode(&result);err != nil {
        resp.Body.Close()
        return nil,err
    }

    resp.Body.Close()
    return &result,nil
}

func main() {
    str := []string{"repo:golang/go is:open json decoder"}
    if res,ok := SearchIssues(str);ok == nil {
        err := mytmp.Execute(os.Stdout,res)
        if err != nil {
            log.Fatalf("execution: %s",err)
        }
    }
}

```

```go
var data struct {
	A	string			//不受信任的纯文本
	B	template.HTML	//受信任的HTML（在template/content.go中命名的字符串类型）
}
```
- 以下形式的函数定义注意返回值括号变量名类型（直接声明了一个返回值变量类型）,可以直接返回(return必须)  

```go
func add(x int) (z int) {
    z = x + x //此处z已经在返回值声明了，不能再声明为一个新的变量
    return
}
```

- go函数参数是`没有默认参数`的
- func Sin(x float64) float64 //没有函数体，说明这个函数使用的GO以外的语言实现，这是声明定义了该函数的签名，此处Sin使用汇编语言实现

- golang.org/x/net 安装方法
为了使包的导入方式不变，我们需要在src目录下面构造目录结构  
$mkdir -p $GOPATH/src/golang.org/x/  
$cd $GOPATH/src/golang.org/x/  
$git clone https://github.com/golang/net.git net  
$go install net  

- 遍历HTML树  

```go
package main

import(
    "fmt"
    "os"
    "net/http"

    "golang.org/x/net/html"
)

//golang.org/x/net/html定义的Node节点类型
type Node struct {
    Type                    NodeType
    Data                    string
    Attr                    []Attribute
    FirstChild,NextSibling  *Node
}

type NodeType int32

const (
    ErrorNode NodeType = iota
    TextNode
    DocumentNode
    ElementNode
    CommentNode
    DoctypeNode
)

type Attribute struct {
    Key,Val string
}

//遍历属性标签a超链接href的地址
func visit(links []string,n *html.Node) []string {
    if n.Type == html.ElementNode && n.Data == "a" {
        for _,a := range n.Attr {
            if a.Key == "href" {
                links = append(links,a.Val)
            }
        }
    }

    for c := n.FirstChild;c != nil;c = c.NextSibling {
        links = visit(links,c)
    }

    return links
}

//遍历节点标签
func outline(stack []string,n *html.Node) {
    if n.Type == html.ElementNode {
        stack = append(stack, n.Data)
        fmt.Println(stack)
    }

    for c := n.FirstChild; c != nil; c = c.NextSibling {
        outline(stack,c)
    }
}

func main(){
    url := "https://github.com/smakry"
    resp,err := http.Get(url)
    if err != nil {
        fmt.Fprintf(os.Stderr,"fetch err:%v\n",err)
        os.Exit(1)
    }

    doc,err := html.Parse(resp.Body)
    resp.Body.Close()
    if err != nil {
        fmt.Fprintf(os.Stderr,"err:%s\n",err)
        os.Exit(1)
    }

    //outline(nil,doc)

	for _, link := range visit(nil, doc) {
		fmt.Println(link)
	}
}

```

- Go的函数调用栈不同于其它语言的大小在64kb到2MB之间，`Go实现可变长的栈`，随使用而增长，可达到1GB左右的上限
- Go语言的垃圾回收机制将回收未使用的内存，但不能指望它会释放未使用的操作系统资源，比如打开的文件已经网络连接，必须下显示地关闭它们  

- 匿名函数  

```go
func test() func() int {
    var x int
    return func () int {
        x++
        return x * x
    }
}

func main(){
    fn := test() //fn保存的是匿名函数func() int {x++ return x * x}地址，所以x变量对于fn是外部变量

    fmt.Println(fn()) //1
    fmt.Println(fn()) //4
    fmt.Println(test()()) //1
    fmt.Println(test()()) //1
}

```

- 匿名函数需要进行递归，必须先声明一个变量然后将匿名函数赋给这个变量。如果将两个步骤合并成一个声明，函数字面量将不能存在于visitAll变量的作用域中，这样也就不能递归地调用自己（`如果定义一句的话，就是先有匿名函数本体，才有变量visitAll`，如果是先声明变量，那是先有变量visitAll匿名函数内部就能看到visitAll这个变量）  

```go
//深度遍历拓扑图
package main

import(
    "fmt"
    "sort"
)

var prereqs = map[string][]string {
    "algorithms":{"data structures"},
    "calcules":{"linear algebra"},
    "compilers":{
        "data structures",
        "formal languages",
        "computer organization",
    },
    "data structures":{"discreate math"},
    "databases":{"data structures"},
}

func topoSort(m map[string][]string) []string {
    var order []string
    seen := make(map[string]bool)
    var visitAll func(items []string)
    visitAll = func(items []string) {
        for _, item := range items {
            if !seen[item] {
                seen[item] = true
                visitAll(m[item])
                order = append(order, item)
            }
        }
    }

    var keys []string
    for key := range m {
        keys = append(keys, key)
    }
    sort.Strings(keys) //未sort顺序是随机的
    visitAll(keys)
    return order
}

func main(){
    for i, course := range topoSort(prereqs) {
        fmt.Printf("%d:\t%s\n", i + 1, course)
    }
}

```

- 捕获迭代变量（迭代变量的内存地址是一致的），通过创建临时变量（每次`迭代都重新分配了地址空间`）  
  
```go
func main(){
    arry := []string{"1","2","4","5","6","7"}

    var temp []string
    for _, v := range arry {
        dir := v //临时变量dir地址是不同的，而迭代变量v地址是一致的
        fmt.Printf("%p,%p\n",&v,&dir)
        temp = append(temp, v)
    }

    fmt.Println(temp)
}

/*输出结果：
0xc000010200,0xc000010210
0xc000010200,0xc000010230
0xc000010200,0xc000010240
0xc000010200,0xc000010250
0xc000010200,0xc000010260
0xc000010200,0xc000010270
[1 2 4 5 6 7]
*/
``` 

- 变长函数的类型（参数可变长）和一个带有普通slice参数的函数类型不相同
    - func f(...int) {} //变长函数（注意省略号位置）,类型是func(...int)   
    - func g([]int) {} //类型是func([]int)  

- defer语句函数或者方法延迟调用。在调用之前加上关键字defer，参数为当前defer调用时候的值，defer的执行被推迟到`包含defer语句函数执行结束之后才被执行到`（return之后，那么可以操作到返回值），且`按照调用defer语句顺序的倒叙执行`（defer调用入栈（参数也入栈），直到当前函数执行结束再从栈取出执行？）。在许多文件系统中，尤其是NFS，`写错误推迟到了文件关闭的时候`，所以如果文件关闭是延迟调用的话，最后文件操作失败会导致数据丢失。  

```go
func test(i int) {
    fmt.Println("call:",i)
}

func main(){
    var a int = 1
    a++
    fmt.Println(a)
    defer test(a + 11)
    a++
    fmt.Println(a)
    defer test(a + 22)
}

/*输出结果
2
3
call: 25
call: 13
*/
```

```go
//defer用于调试
func test(msg string) func() {
    start := time.Now()
    log.Printf("enter %s", msg)
    return func() {
        log.Printf("exit %s (%s)\n", msg, time.Since(start))
    }
}

func main(){
    defer test("main")() //注意这里的()不能少，相当于先调用test("main")，再延迟调用返回的匿名函数
    time.Sleep(2 * time.Second)
}

```

```go
func test(i int) (res int) {
    defer func(){ res += i}() //defer调用可以操作到最后的返回值res，因为defer在return之后执行
    return i + i
}

func main(){
    fmt.Println(test(2)) //6
}

```

- Go的宕机机制让`延迟执行的函数在栈清理之前调用`（可用延迟函数转移堆栈信息用于排查）；defer panic recover构成异常处理机制（recover类似catch，捕获异常处理；defer相当于finally）。`利用recover处理panic指令，defer必须在panic之前声明，否则当panic时，recover无法捕获到panic`    
<https://www.jianshu.com/p/0cbc97bd33fb> 

```GO
func main() {
      fmt.Println("c")
   defer func() { // 必须要先声明defer，否则不能捕获到panic异常
      fmt.Println("d")
      if err := recover(); err != nil { // recover捕获了异常
         fmt.Println(err) // 这里的err其实就是panic传入的内容
      }
      fmt.Println("e")
   }()
   f() //开始调用f
   fmt.Println("f") //这里开始下面代码不会再执行
}

func f() {
   fmt.Println("a")
   panic("异常信息")
   fmt.Println("b") //这里开始下面代码不会再执行
}
-------output-------
c
a
d
异常信息
e
````

```go
package main

import(
    "fmt"
    "runtime"
)

func f(x int) {
    fmt.Printf("f(%d)\n", x + 0 / x)
    defer fmt.Printf("defer %d\n", x)
    f(x - 1)
}

func printStack() {
    var buf [4096]byte
    n := runtime.Stack(buf[:], false) //转存堆栈信息

    fmt.Println(string(buf[:n])) 
}   

func main() {
    defer printStack()
    f(3)
}  
```

- 方法
    - func (p Point) Distance() float64 表达式p.Disatance称作选择子（为p选择合适的子方法）  
    - Go可以将方法绑定到任何类型上（如数字、字符串、slice、map甚至函数等定义附加行为）
    - (\*Point).ScaleBy，圆括号必须，没有表达式被解析*(Point.ScaleBy)
    - 习惯上遵循如果类型的任何一个方法是使用指针接收者，那么所有的该类型的方法都应该使用指针接收（虽然部分方法不一定需要使用指针接收）(2种方式定义的方法都属于该类型的方法)  
    - 本身是指针类型不能作为接收者（假设可以，那么*指针类型是不是跟原有的类型混淆）

```go
type Point struct {
    X, Y float64
}

type PP *Point

// PP作为接收者是非法的
func (x PP) test(){ 

}

```

- “.”同样适用于结构体相当于其它语言的“->”，go编译器会对变量进行隐式的转换（必须`能够隐式的转换`），合法的方法调用表达式有以下几种：

```go
type Point struct {
    X, Y float64
}

//接收者Point类型
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X - p.X, q.Y - p.Y)
}

func main() {
    a := Point{ 10, 11}
    b := Point{ 11, 12}

    fmt.Println(b.Distance(a)) //合法，Point类型
    fmt.Println(Point{1,2}.Distance(a)) //合法，Point类型
    fmt.Println((&Point{2,3}).Distance(a)) //合法，*Point类型隐式转成Point类型
}	
```

```go
type Point struct {
    X, Y float64
}

//接收者*Point类型
func (p *Point) Distance(q Point) float64 {
    return math.Hypot(q.X - p.X, q.Y - p.Y)
}

func main() {
    a := Point{ 10, 11}
    b := Point{ 11, 12}

    fmt.Println(b.Distance(a)) //合法，Point类型转成*Point类型
//  fmt.Println(Point{1,2}.Distance(a)) //不合法，类型字面量无法获取地址不能隐式转换
    fmt.Println((&Point{2,3}).Distance(a)) //合法，*Point类型
}
```

- Go匿名类型展开，查找`先在当前类型的方法中查找`，再到成员类型中查找方法，当`同一级出现同名的会报错`（模拟两可选择错误，但可以明确指明调用哪个成员的方法）。

```go
type t1 struct {}

func (t t1) test() {
    fmt.Println("t1test")
}

type t2 struct {}

func (t t2) test() {
    fmt.Println("t2test")
}

type t3 struct {
    t1
}

type t4 struct {
    t3
}

func (t t4) test() {
    fmt.Println("t4test")
}

type t5 struct {
    t1
    t2
}

func main() {
    var a t4
    a.test() //t4test

    var b t5
    b.t1.test() //t1test

    var b t5
    b.test() //ambiguous selector b.test (test模棱两可)
}

```

```go
package main

import (
    "fmt"
)

type Base struct {
}

type IAICreter interface {
    Create(typ int) IAI
}

type IAI interface {
    Init()
    Run()
    Stop()
}

type TeStr struct {
    Base
}

func (this *Base) Init() { // 这个是base的
    fmt.Println("this is Init")
}

func (this *TeStr) Run() {
    fmt.Println("this is Run")
}

func (this *TeStr) Stop() {
    fmt.Println("this is Stop")
}

func (this *TeStr) Create(typ int) IAI {
    fmt.Println("this is Create")
    return this
}

var _ IAICreter = (*TeStr)(nil) //TeStr先在自己的方法中接口的方法，再在成员类型Base中找（此处的Init就是）

func main() {

}

```

- vim 滚屏
Ctrl + F 屏幕向下滚动一屏  
Ctrl + B 屏幕向上滚动一屏  
Ctrl + E 屏幕向下滚动一行  
Ctrl + Y 屏幕向上滚动一行  
Ctrl + D 屏幕向下滚动半屏  
Ctrl + U 屏幕向上滚动半屏  

- 位向量（使用`二进制位做数据存储`），以下例子使用“二维”数组存储（一维存储64个数据，二维也存储64个数据）

```go
package main

import(
    "fmt"
    "bytes"
)

type IntSet struct {
    words []uint64
}

func (s *IntSet) Has(x int) bool {
    word, bit := x / 64, uint(x % 64)
    return word < len(s.words) && s.words[word] & (1 << bit) != 0
}

func (s *IntSet) Add(x int) {
    word, bit := x / 64, uint(x % 64)
    fmt.Println(word,bit)
    for word >= len(s.words) {
        s.words = append(s.words, 0)
    }

    s.words[word] |= 1 << bit
}

func (s *IntSet) UnionWith(t *IntSet) {
    for i, tword := range t.words {
        if i < len(s.words) {
            s.words[i] |= tword
        } else {
            s.words = append(s.words, tword)
        }
    }
}

func (s *IntSet) String() string {
    var buf bytes.Buffer
    buf.WriteByte('{')
    for i, word := range s.words {
        if word == 0 {
            continue
        }

        for j := 0; j < 64; j++ {
            if word & (1 << uint(j)) != 0 {
                if buf.Len() > len("{") {
                    buf.WriteByte(' ')
                }
                fmt.Fprintf(&buf, "%d", 64 * i + j)
            }
        }
    }

    buf.WriteByte('}')
    return buf.String()
}

func main() {
    var x, y IntSet
    x.Add(1)
    x.Add(144)
    x.Add(9)
    fmt.Println(x.String())

    y.Add(9)
    y.Add(42)
    fmt.Println(y.String())

    x.UnionWith(&y)
    fmt.Println(x.String())
    fmt.Println(x.Has(9), x.Has(123))
}

```

- Go封装一个对象，必须使用结构体（通过大小写是否导出），Go封装的单元是包而不是类型
1. 对于结构体
```go
type Person struct {
    age int
}

// 接收者也是值类型
func (p Person) howOld() int {
    return p.age
}

// 接收者是指针类型
func (p *Person) growUp() {
    p.age += 1
}

func main() {
    // qcrao 是值类型
    qcrao := Person{age: 18}

    // 值类型 调用接收者也是值类型的方法
    fmt.Println(qcrao.howOld())

    // 值类型 调用接收者是指针类型的方法
    qcrao.growUp()
    fmt.Println(qcrao.howOld())

    // stefno 是指针类型
    stefno := &Person{age: 100}

    // 指针类型 调用接收者是值类型的方法
    fmt.Println(stefno.howOld())

    // 指针类型 调用接收者也是指针类型的方法
    stefno.growUp()
    fmt.Println(stefno.howOld())
}
```

实际上，当类型和方法的接收者类型不同时，编译器在背后做了一些工作：
a. 值接收者
    - 值类型调用者：方法会使用调用者的一个副本，类似于“传值”
    - 指针类型调用者：`指针被解引用为值`，上例中，stefno.howOld()实际上是(\*stefno).howOld()
b. 指针接收者：
    - 值类型调用者：`使用值的引用来调用方法`，上例中，qcrao.growUp()实际上是(&qcrao).growUp()
    - 指针类型调用者：实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参数，拷贝了一份指针

2. 对于接口
```go
package main

import "fmt"

type coder interface {
    code()
    debug()
}

type Gopher struct {
    language string
}

func (p Gopher) code() {
    fmt.Printf("I am coding %s language\n", p.language)
}

func (p *Gopher) debug() {
    fmt.Printf("I am debuging %s language\n", p.language)
}

func main() {
    var c coder = &Gopher{"Go"}
    c.code()
    c.debug()

    var c2 coder = Gopher{"Go"}
    // c2.code() // 开启后会抛错，并没有实现code
    // c2.debug()
}
```

例子中 &Gopher{"Go"} 与 Gopher{"Go"} 差异，c实现了coder的2个方法，c2并没有实现coder的方法。原因是接收者是指针类型的方法，可能会在方法中对接收者对属性进行更改操作，从而影响接收者。
而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。

结论：
a. 实现了接收者是值类型的接口方法，相当于自动实现了接收者是指针类型的方法（如上的c）
b. 实现了接收者是指针类型的接口方法，不会自动实现对应接收者是值类型的方法（如上的c2）

3. 两者分别在何时使用
如果方法的接收者是值类型，无论调用者是对象还是对象指针，`修改的都是对象的副本`，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。

- sublime-text安装 <https://www.iteye.com/blog/gxl-ct001-2441108>  
自定义主题 <http://tmtheme-editor.herokuapp.com/#!/editor/local/Monokai>

- 接口（抽象类（接口），派生类（结构体类型等）必须实现抽象类的所有方法）
    - 一个接口类型定义了一套方法，如果一个具体类型要实现该接口，那么必须实现接口类型中定义的`所有方法`。（接口类型抽象类，具体类型相当于子类，必须实现抽象类的所有方法）
    - 接口是一些方法的集合，而结构体是一些数据类型的集合，结构体的方法定义在声明之外？  

```go
type Reader interface {
	Read() int
	test()
}

func (p *MyReadWriter) Read() int {
	return 1
}

type Closer interface {
	Close() int
}

func (p *MyReadWriter) Close() int {
	return 2
}

//组合了Reader和Closer的接口，同结构体，可展开接口方法使用
type ReadWriter interface {
	Read() int
	Closer
}

type MyReadWriter struct {}

func main() {
	var s Reader
	s = new(MyReadWriter) //本例报错，MyReadWriter没有实现test()方法
	fmt.Println("",s.Read())
}
```

- interface{} (空接口`类型`，它也是一种类型)，可以表示任何类型（接口的零值就是把它的动态类型的和值都设置为nil）  

```go
	var x interface{} = 10
	fmt.Printf("%v, %[1]T\n", x.(int)) //10, int  直接断言x是int类型
```

- 空的interface可以接受任何类型的参数，但是interface{}类型的slice（[]interface{}）不能接受任何类型的slice。但可以通过遍历转化（深度复制，转化为interface来进行转化）

```go
package main  

import "fmt"

func printAll(vals []interface{}) {
    for _, val := range vals {
        fmt.Println(val)
    }
}

func main() {
    names := []string{"hello", "world"}
    printAll(names)
}

结果：
cannot use names (type []string) as type []interface {} in argument to printAll
```

- flag.Parse() 命令行参数解析
<https://www.jianshu.com/p/f9cf46a4de0e>

- 使用flag.Value来解析参数（设置全局flag值period2，flag.Parse()接收命令行参数，操作flag值）

```go
var period = flag.Duration("period2", 1 * time.Second, "sleep period")

func main() {
	flag.Parse()
	fmt.Printf("Sleeping for %v...", *period)
	time.Sleep(*period)
	fmt.Println()
}
```

- 接口**值**`可以用==和！=操作符来做比较`，如果两个接口值都是nil或者二者的动态类型完全一致且二者动态值相等（使用动态类型的==操作符来做比较），那么两个接口值相等（能比较就能作为map的键）。但需注意接口类型一致，但是值是不可比较的会导致崩溃（不矛盾）  
- 部分数据类型要转成声明类型是因为声明的类型包含额外的方法
- sort.Sort(data Interface)是接口的一个应用，类型实现了接口方法即可用于排序

```go
type Interface interface {
	// Len is the number of elements in the collection.
	Len() int
	// Less reports whether the element with
	// index i should sort before the element with index j.
	Less(i, j int) bool
	// Swap swaps the elements with indexes i and j.
	Swap(i, j int)
} 
```

```go
package main

import(
	"fmt"
	"time"
	"os"
	"sort"
	"text/tabwriter"
)

type Track struct {
	Title	string
	Artist	string
	Album	string
	Year	int
	Length	time.Duration
}

var tracks = []*Track {
	{"Go", "Delilah", "From the Roots Up", 2012, length("3m38s")},
	{"Go", "Moby", "Moby", 1992, length("3m37s")},
	{"Go Ahead", "Alicia Keys", "As I Am", 2007, length("4m36s")},
	{"Ready 2 Go", "Martin Solveig", "Smash", 2011, length("4m24s")},
}

func length(s string) time.Duration {
	d, err := time.ParseDuration(s)
	if err != nil {
		panic(s)
	}

	return d
}

func printTracks(tracks []*Track) {
	const format = "%v\t%v\t%v\t%v\t%v\t\n"
	tw := new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, ' ', 0)
	fmt.Fprintf(tw, format, "Title", "Artist", "Album", "Year", "Length")
	fmt.Fprintf(tw, format, "-----", "-----", "-----", "-----", "-----")
	for _, t := range tracks {
		fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)
	}

	tw.Flush()
}

type byArtist []*Track

func (x byArtist) Len() int {
	return len(x)
}

func (x byArtist) Less(i, j int) bool {
	return x[i].Artist < x[j].Artist
}

func (x byArtist) Swap(i, j int) {
	x[i], x[j] = x[j], x[i]
}

func main() {
	sort.Sort(byArtist(tracks)) //反序可用sort.Reverse无需再定义
	printTracks(tracks)
}
```

- http.Handler接口

```go
//switch分发
package main

import(
	"fmt"
	"log"
	"net/http"
)

type dollars float32

func (d dollars) String() string {
	return fmt.Sprintf("$%.2f",d)
}

type database map[string]dollars

func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	switch req.URL.Path {
	case "/list":
		for item, price := range db {
			fmt.Fprintf(w, "%s: %s\n", item, price)
		}
	case "/price":
		item := req.URL.Query().Get("shoes")
		price, ok := db[item]
		if !ok {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		fmt.Fprintf(w, "Price is : %s\n", price)
	default:
		w.WriteHeader(http.StatusNotFound)
		fmt.Fprintf(w, "no such page: %s\n", req.URL)
	}
}

func main() {
	db := database{"shoes": 50, "socks": 5}
	fmt.Println(db["shoes"])
	log.Fatal(http.ListenAndServe("localhost:8000", db))
}
```  

```go
//多工转发器ServerMux
package main

import(
	"fmt"
	"log"
	"net/http"
)

type dollars float32

func (d dollars) String() string {
	return fmt.Sprintf("$%.2f",d)
}

type database map[string]dollars

func(db database) list(w http.ResponseWriter, req *http.Request) {
	for item, price := range db {
		fmt.Fprintf(w, "%s: %s\n", item, price)
	}
}

func(db database) price(w http.ResponseWriter, req *http.Request) {
	fmt.Println("this is price")
	item := req.URL.Query().Get("shoes")
	price, ok := db[item]
	if !ok {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	fmt.Fprintf(w, "Price is : %s\n", price)
}

func main() {
	db := database{"shoes": 50, "socks": 5}
	mux := http.NewServeMux()
	mux.Handle("/list", http.HandlerFunc(db.list))
	mux.Handle("/price", http.HandlerFunc(db.price))
	log.Fatal(http.ListenAndServe("localhost:8000", mux))
}

/*使用系统的全局Mux变量DefaultServeMux，方法是HandleFunc（注意没有r）
func main() {
	db := database{"shoes": 50, "socks": 5}
	http.HandleFunc("/list", db.list)
	http.HandleFunc("/price", db.price)
	log.Fatal(http.ListenAndServe("localhost:8000", nil))
}
*/
```

- 类型断言（`作用在接口值上`的操作，x.(T)其中`x是一个接口类型`的表达式，`T是一个类型`（称为断言类型））。实际上类型断言就是从它的操作数中把具体类型的值提出来的操作，如果检查失败那么操作崩溃。（判断是不是自己或者是不是自己的祖先？）

    - 如果断言类型T是一个具体类型，那么类型断言会检查x的动态类型是否就是T，如果检查成功，那么断言的结果就是x的动态值，类型当然就是T。
    - 如果断言类型T是一个接口类型，那么类型断言检查x的动态类型是否满足T，如果成功动态值没有提取出来，结果仍然还是一个接口值，接口值的类型和值部分也没有变更，`只是结果的类型为接口类型T`（类型断言是一个接口值表达式，从一个接口类型变为`拥有另外一套方法`的接口类型，但保留了接口值中的动态类型和动态值部分）。

```go
func test(x interface{}) {
	switch x.(type) {
	case int:
		fmt.Println("this is int")
	case bool;
		if x == true {
			fmt.Println("true")
		}
	default:
		fmt.Println("no found")
	}
}

func main() {
	test(1)
}
```

```go
package main

import(
	"fmt"
)

type IntOne interface {
	Read() int
}

type IntTwo interface {
	Read() int
	Write() int
}

type TypeOne struct {}

type TypeTwo struct {}


func (t TypeOne) Read() int {
	return 1
}

func (t TypeTwo) Read() int {
	return 2
}

func (t TypeTwo) Write() int {
	return 3
}

func main() {
	var a IntOne = new(TypeOne)
	var b IntTwo = new(TypeTwo)

	fmt.Printf("a is type IntOne : %T\n", a.(IntOne))
	if f, ok := a.(IntTwo); !ok { //同map及slice用于判断元素是否存在
		fmt.Printf("a is type IntTwo error and type is : %T\n", f)
	} else {
		fmt.Printf("a is type IntTwo : %T\n", f)
	}
	fmt.Printf("b is type IntOne : %T\n", b.(IntOne))
	fmt.Printf("b is type IntTwo : %T\n", b.(IntTwo))
}
/*输出结果
a is type IntOne : *main.TypeOne
a is type IntTwo error and type is : <nil>
b is type IntOne : *main.TypeTwo
b is type IntTwo : *main.TypeTwo

*/
```

- 使用类型断言来识别错误。如果错误消息已被fmt.Errorf这类的方法合并到一个大字符串中，那么PathError的结构信息就丢失了，`错误识别通常必须失败操作发生时马上处理`。

```go
package main

import(
	"fmt"
	"os"
)

// os包的PathError结构体
// type PathError struct {
// 	Op   string
// 	Path string
// 	Err  error
// }

func main() {
	_, err := os.Open("/no/such/file")
	fmt.Println(err)

	if pErr, ok := err.(*os.PathError); ok {
		fmt.Println(os.IsNotExist(pErr.Err))
	}
}
```

- 使用类型断言来判定是否拥有某种方法。

```go
func writeString(w io.Writer, s string) (n int, err error) {
	type stringWriter interface {
		WriteString(string) (n int, err error)
	}

	if sw, ok := w.(stringWriter); ok { //用于判定io.Writer是否有WriteString方法
		return sw.WriteString(s)
	} 

	...
}
```

- 基于标记的xml解析

```go
package main

import (
	"encoding/xml"
	"fmt"
	"io"
	"os"
	"strings"
	"net/http"
)

func containsAll(x, y []string) bool {
	for len(y) <= len(x) {
		if len(y) == 0 {
			return true
		}

		if x[0] == y[0] {
			y = y[1:]
		}

		x = x[1:]
	}
	return false
}

func main() {
	url := "https://github.com/smakry"
	resp,err := http.Get(url)
	if err != nil {
		fmt.Fprintf(os.Stderr,"fetch err:%v\n",err)
		os.Exit(1)
	}

	dec := xml.NewDecoder(resp.Body)
	defer resp.Body.Close()

	var stack []string
	for {
		tok, err := dec.Token()
		if err == io.EOF {
			break
		} else if err != nil {
			fmt.Fprintf(os.Stderr, "xmlselect: %v\n", err)
			os.Exit(1)
		}

		switch tok := tok.(type) {
		case xml.StartElement:
			stack = append(stack, tok.Name.Local)
		case xml.EndElement:
			stack = stack[:len(stack) - 1]
		case xml.CharData:
			if containsAll(stack, os.Args[1:]) {
				fmt.Printf("%s: %s\n", strings.Join(stack, " "), tok)
			}
		}
	}
}
```

- 回声服务器

```go
//服务端
package main

import (
	"fmt"
	"strings"
	"bufio"
	"log"
	"net"
	"time"
)

func myConnect() {
	listener, err := net.Listen("tcp", "localhost:8000")
	if err != nil {
		log.Fatal(err)
	}
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err)
			continue
		}

		handleConn(conn)
	}
}

func echo(c net.Conn, shout string, delay time.Duration) {
	fmt.Fprintln(c, "\t", strings.ToUpper(shout))
	time.Sleep(delay)
	fmt.Fprintln(c, "\t", shout)
	time.Sleep(delay)
	fmt.Fprintln(c, "\t", strings.ToLower(shout))
}

func handleConn(c net.Conn) {
	input := bufio.NewScanner(c)
	for input.Scan() {
		echo(c, input.Text(), 1 * time.Second)
	}

	c.Close()
}

func main() {
	myConnect()
}
```

```go
//客户端
package main

import (
	"io"
	"os"
	"log"
	"net"
)

func myListen() {
	conn, err := net.Dial("tcp", "localhost:8000")
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()
	go mustCopy(os.Stdout, conn)
	mustCopy(conn, os.Stdin)
}

func mustCopy(dst io.Writer, src io.Reader){
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}

func main() {
	myListen()
}
```

- 通道chan
    - 像map一样，通道是一个使用make创建的数据结构的引用，当复制或者作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用同一份数据结构。
    - 通道零值是nil。通道可以比较
    - 通道支持关闭，关闭后的通道发送操作将导致宕机，而`接收操作将获取所有已经发送的值，直到通道为空`（同signal？） 

- 无缓冲通道（make第2个参数是0或者无第2个参数），`发送操作将会阻塞`，直到`另一个`goroutine在对应的通道上执行接收操作（此时发送的goroutine将阻塞后续逻辑将不执行）

```go
func test(c chan int) {
	fmt.Println(<- c)
}

func main() {
	c := make(chan int)
	go test(c)
	x := 10
	c <- x
//	go test(c) //若goroutine在这调用会导致通道阻塞而执行不到这

	time.Sleep(1 * time.Second)
}
```

- goroutine泄漏（多个无缓冲通道，只接收了一个或者多个，部分没有接收，导致一直阻塞），泄漏的goroutine不会被自动回收

```go
func mirroredQuery() string {
	responses := make(chan string)
	go func() {responses <- "gorountine one"}()
	go func() {responses <- "gorountine two"}()
	go func() {responses <- "gorountine three"}()

	return <- responses
}
```

- 通道可通过"\_, ok := <- 通道名"来判定是否已经关闭，通过close(通道名)的方式，若尝试关闭已经关闭的通道会导致宕机。同时可以通过range方式来做对应的通道接收，通道可通过垃圾回收器回收而不是通过close方式。  

```go
package main

import (
	"fmt"
)

func main() {
	naturals := make(chan int)
	squares := make(chan int)

	go func() {
		for x := 0; x < 5 ; x++ {
			naturals <- x
		}

		close(naturals)
	}()

	go func() {
		for {
			x, ok := <- naturals
			if !ok { //通过接收方式判定
				break
			}
			squares <- x * x	
		}
		
		close(squares)
	}()

	for y := range squares { //通过range判定
		fmt.Println(y)
	}
}
```

- 通道作为函数参数（`双向通道可隐式转成单向通道，但是反过来是不成立的`）
     - func test(c chan int) //c是一个双向通道允许收发
     - func test(c chan<- int) //c是一个单向通道，仅允许发（通过<-指向的chan记忆）
     - func test(c <-chan int) //c是一个单向通道，仅允许收

- 缓冲通道（make的第2个参数指定缓冲大小，eg：make(chan int, 5)），缓冲通道实际上是一个队列。当队列满了以后通道一样阻塞

- 通道赋值（只是把通道里面的值复制(包含通道当前的方向？)，不是地址的赋值，同其它一样，通道本身不是一个地址）

```go
func test(in chan int) chan int {
    // <-in
    ch2 := make(chan int)
    go func() {
        ch2 <- 11
    }()
    return ch2
}

func main() {
    ch := make(chan int)
    fmt.Println(&ch)
    go func() {
        ch <- 5
    }()
    ch = test(ch)

    fmt.Println(<-ch, &ch)
}
```

- 并行循环

```go
func handleFile(filenames []string) {
	ch := make(chan struct{})
	for _, f := range filenames {
		go func(f string) {
			//各文件单独循环
			ch <- struct{}{}
		}(f) //此处一定要显示的调用，如果不是f作为一个变量地址不变，每次循环f值是变化的
	}

	for range filenames { //这个是必要的，等待所有的文件都处理完成，若没有接收，goroutine可能没执行完成就已经被主goroutine结束了
		<- ch
	}
}
```

```go
//计数器sync.WaitGroup（Add增加计数，Done减少计数，wait等待计数=0继续往下执行）
func makeThumnail(filenames <-chan string) int64 {
	sizes := make(chan int64)
	var wg sync.WaitGroup
	for f := range filenames {
		wg.Add(1) // add的位置注意
		go func(f string) {
			defer wg.Done() //保证一定会调用
			x, err := test()
			if err != nil {
				log.Println(err)
				return
			}

			sizes <- x
		}(f)
	}

	go func() {
		wg.Wait()
		close(sizes)
	}()

	var total int64
	for size := range sizes {
		total += size
	}
	return total
}
```

- 标签化的break语句

```go
func main() {

flag:
    for {
        for {
            time.Sleep(1 * time.Second)
            break flag //跳出循环到flag层
        }
        fmt.Println("ggoo")
    }

}
```

- 以下可能的输出结果，由于多核，goroutine在不同的CPU上执行（拥有自己独立的缓存，彼此之间不可见），也就不是简单的多个goroutine交错执行。（CPU缓存在同步到内存之前的这段期间，不同的goroutine是不可见）

```go
var x, y int
go func() {
	x = 1
	fmt.Print("y:", y, " ")
}()

go func() {
	y = 1
	fmt.Print("x:", x, " ")
}()
/*可能结果
x,y的先后顺序以及各种值都有可能
*/
```

- 通道轮询（select语句尝试从通道接收一个值，如果没有值，它什么也不做，这是一个非阻塞的接收操作，重复这个动作称为对通道轮询）
```go
select{
case <- abort:
	fmt.Printf("abort\n")
	return
default:
	//do nothing
}
```

- 让多个goroutine停止（利用通道关闭，且已经取完所有发送的值之后，接下来的接收操作立即返回，得到零值。利用它创建广播机制）

```go
package main

import (
    "fmt"
    "time"
)

func main() {

    x := make(chan struct{})

    go func() {
        time.Sleep(1 * time.Second)
        close(x)
    }()
    
    for i := 0; i < 5; i++ {
        go func(c chan struct{}, in int) {
            for { 
                time.Sleep(1 * time.Second / 5)
                select {
                case x := <-c: //1s后通道关闭，此处接收的是c的零值struct{}{}
                    fmt.Printf("%T, %[1]v", x)
                    fmt.Println("this is case c")
                default: //1s内通道未关闭，执行默认逻辑
                    fmt.Println("this is Defalut")
                }   
            }
        }(x, i)
    }

    time.Sleep(3 * time.Second)
}
```

- Go互斥锁（sync.Mutex）和读写锁（sync.RWMutex）

1.什么时候需要用到锁？  
 1）多个线程在读相同的数据时  
 2）多个线程在写相同的数据时  
 3）同一个资源，有读又有写  

2.互斥锁控制资源的访问，每一个时刻只有一个线程能够拿到锁（不管读或者写）。

```go
package main
import ("fmt"
    "sync"
)

var (
    count int
    lock sync.Mutex
)

func main() {
    for i := 0; i < 2; i++ {
        go func() {
            for i := 1000000; i > 0; i-- {
                lock.Lock()
                count ++
                lock.Unlock()
            }
            fmt.Println(count)
        }()
    }

    fmt.Scanf("\n")  //等待子线程全部结束
}

运行结果：
1952533
2000000  //最后的线程打印输出
```
3.在读多写少的环境下，共享资源的方式可采用读写锁（效率高，读可以多执行）  
 1）读获得锁后，写拿不到锁，但是另一个读线程可以拿到读锁  
 2）写获得锁，不管读或者写都拿不到锁，此时同互斥锁都作用。 

4.锁的类型是一个`结构体类型`，属于值类型的一种，将它当作参数传给一个函数，将它从函数中返回，把它赋值给其他变量，让它进入某个管道，都会导致他的`副本的产生`，并且原值和副本以及多个副本之间是完全独立的，他们都是`不同`的互斥锁，所以不应该将锁通过函数的参数进行传递。  

- 并发安全（考虑一个能在串行程序中正确工作的函数，如果这个函数在`并发调用时仍然能正确工作`，那么这个函数是并发安全。）
- 竞态（多个goroutine按某些交错顺序执行时程序无法给出正确的结果）。数据竞态（发生于两个goroutine`并发读写`同一个变量且至少其中一个是写入时，比如：a写入200，同时b写入100，竞态最后只写入了200）。避免数据竞态的方式： 
    - 不要修改变量
    - 避免从多个goroutine访问同一个变量（当多个goroutine会访问到同一个变量，可以通过控制让同一时刻只有一个goroutine可以访问）
    - 互斥机制

- 一个计数`上限为1的信号量`称为二进制信号量
- 临界区域（在`互斥锁Lock和Unlock之间的代码`，可以自由地读取和修改共享变量，这一部分称为临界区域）
- 读写互斥锁sync.RWMutex（允许只读操作可以并发执行，但写操作需要获得完全独享的访问权限。也叫做多读单写锁。多读可能同时发生了写所以需要这个读锁而不直接抛弃读锁的原因？）。RLock()和RUnlock()分别获取和释放一个读锁（也称为共享锁）.
    - RLock仅可用于临界区域内对共享变量无写操作的情形。
    - 仅在绝大部分goroutine都在获取读锁且锁竞争比较激烈时（即goroutine一般都需要等待后才能获得锁），RWMutex才有优势。因为`RWMutex需要更复杂的内部簿记工作`，所以`在竞争不激烈时它比普通的互斥锁慢` 

```go
var mu sync.RWMutex
var icons map[string]image.Image

func Icon(name string) image.Image {
	mu.RLock() //读锁（共享锁）
	if icons != nil {
		icon := icons[name]
		mu.RUnlock()
		return icon
	}
	mu.RUnlock() //不释放共享锁无法直接升级到互斥锁

	mu.Lock() 
	if icons == nil { //同样需要判断是否存在可能其它的goroutine同步在初始化
		loadIcons() //icons初始化方法
	}
	icon := icons[name]
	mu.Unlock()
	return icon
}
```

```go
//使用sync包的Once简化上面的方法（本质就是用一个互斥锁来标记数据是否已经被初始化过）
var loadIconsOnce sync.Once
var icons map[string]image.Image

func Icon(name string) image.Image {
	loadIconsOnce.Do(loadIcons) //loadIcons是icons初始化方法
	return icons[name]
}
```

- Go箴言“不要通过共享内存来通信，而应该通过通信来共享内存”。（单个goroutine操作可能是竞态数据，通过通信方式避免竞态数据）。使用通道请求来代理一个受限变量的所有访问的goroutine称为该变量的监控goroutine

- 竞态检测器。简单地把`-race命令行参数`加到go build、go run、go test命令里边即可使用该功能，它会让`编译器`为你的应用或者测试构建一个修改后的版本。这个版本有额外的手法用于高效记录在执行时对共享变量的所有访问，以及读写这些变量的goroutine标识。修改后的版本还会记录所有的同步事件，包括go语句、通道操作、(*sync.Mutex).Lock调用、(*sync.WaitGroup).Wait调用等。（完整的同步事件集合可以在语言规范中“The Go Memory Model”文档中找到） 

- 并发非阻塞缓存

```go
// 共享变量并上锁
type Memo struct {
	f		Func
	cache	map[string]*entry
}

type Func func(key string) (interface{}, error) {}

type result struct {
	value	interface{}
	err		error
}

type entry struct {
	res		result
	ready	chan struct{}
}

func New(f Func) *Memo {
	return &Memo{f: f, cache: make(map[string]*entry)}
}

func (memo *Memo) Get(key string) (value interface{}, err error) {
	memo.mu.Lock()
	e := memo.cache[key]
	if e == nil {
		e = &entry{ready: make(chan struct{})}
		memo.cache[key] = e
		memo.mu.Unlock()

		e.res.value, e.res.err = memo.f(key)
		close(e.ready)
	} else {
		memo.mu.Unlock()
		<-e.ready
	}

	return e.res.value, e.res.err
}

func test() {
	m := New(httpGetBody)
	var n sync.WaitGroup
	for url := range incomingURLs() {
		n.Add(1)
		go func(url string) {
			start := time.Now()
			value, err := m.Get(url)
			if err != nil {
				log.Print(err)
			}

			fmt.Printf("%s, %s, %d bytes\n", url, time.Since(start), len(value.([]byte)))			
			n.Done()
		}
	}

	n.Wait()
}
```

```go
// 通信顺序进程方案
func test() {
	m := New(httpGetBody) //httpGetBody为爬取函数
	var n sync.WaitGroup
	for url := range incomingURLs() {
		n.Add(1)
		go func(url string) {
			start := time.Now()
			value, err := m.Get(url)
			if err != nil {
				log.Print(err)
			}

			fmt.Printf("%s, %s, %d bytes\n", url, time.Since(start), len(value.([]byte)))			
			n.Done()
		}
	}

	n.Wait()
}

type Func func(key string) (interface{}, error)

type result struct {
	value	interface{}
	err		error
}

type entry struct {
	res		result
	ready	chan struct{}
}

type request struct {
	key			string
	response	chan<- result
}

type Memo struct {
	requests	chan request
}

func New(f Func) *Memo {
	memo := &Memo{requests: make(chan request)}
	go memo.server(f)
	return memo
}

func (memo *Memo) Get(key string) (interface(), error) {
	response := make(chan result)
	memo.requests <- result{key, response}
	res := <-response
	return res.value, res.err
}

func (memo *Memo) Close() {
	close(memo.requests)
}

func (memo *Memo) server(f Func) {
	cache := make(map[string]*entry)
	for req := range memo.requests {
		e := cache[req.key]
		if e == nil {
			e = &entry{ready: make(chan struct{})}
			cache[req.key] = e
			go e.call(f, req.key)
		}
		go e.deliver(req.response)
	}
}

func (e *entry) call(f Func, key string) {
	e.res.value, e.res.err = f(key)
	close(e.ready)
}

func (e *entry) deliver(response chan<- result) {
	<-e.ready
	response <- e.res
}
```

- 用互斥锁保护一个数值型的共享资源麻烦且效率低下，标准库的sync/atomic包对原子操作提供了丰富的支持

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

var total uint64

func worker(wg *sync.WaitGroup) {
    defer wg.Done()

    for i := uint64(0); i <= 100; i++ {
        atomic.AddUint64(&total, i)
    }
}

func main() {
    var wg sync.WaitGroup
    wg.Add(2)

    go worker(&wg)
    go worker(&wg)
    wg.Wait()

    fmt.Println(total)
}
```

- 原子操作配合互斥锁可以实现非常高效的单件模式（单例模式），互斥锁的代价比普通整数的原子读写个高很多，在性能敏感的地方可以增加一个数字型的标志位，通过原子检测标志位状态降低互斥锁的使用次数来提供性能。(及sysnc.Once的实现？)

```go 
import (
    "sync"
    "sync/atomic"
)

// 自定义的数据结构体
type singleton struct{}

var (
    instance    *singleton
    initialized uint32
    mu          sync.Mutex
)

func Instance() *singleton {
    if atomic.LoadUint32(&initialized) == 1 { // 用原子操作先做一层处理，减少互斥锁的使用
        return instance
    }

    mu.Lock()
    defer mu.Unlock()

    if instance == nil { // 加锁时可能其它操作已经改变该值？
        defer atomic.StoreUint32(&initialized, 1)

        instance = &singleton{}
    }
    return instance
}
```

- goroutine与操作系统线程的差别
    - **栈增长方式**：
        - `goroutine是可增长的栈`。典型情况下初始大小2kb，栈可动态扩容到1GB，按需增大和缩小。
        - OS线程是固定大小的栈内存（通常是2MB） 
	- **调度方式**：
        - OS线程由OS内核来调度。每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个叫调度器的内核函数。这个函数暂停当前正在运行的线程，把它的寄存器信息保存在内存，查看线程列表并决定接下来运行哪个线程，再从内存恢复线程的注册表信息，最后继续执行选中的线程。因为OS线程由内核来调度，所以控制权限从一个线程到另外一个线程需要一个完整的`上下文切换`：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。考虑这个操作涉及的内存局域性以及涉及的内存访问数量，还是有访问内存所需要的CPU周期数量的增加，这个操作是很慢的。（需要`切换内存及缓存`？）
        - Go包含一个自己的调度器，这个调度器使用一个称为`m:n调度`的技术（因为它可以复用/调度m个goroutine到n个OS线程）。Go调度器与内核调度器的工作类似，但Go调度器`只需关心单个Go程序的goroutine调度问题`。Go调度器不是由硬件时钟来定期触发的，而是由特定的Go语言结构来触发的。比如当一个goroutine调用time.Sleep或者被通道阻塞或对互斥量操作时，调度器就会将这个goroutine设为休眠模式，并运行其它goroutine直到前一个可重新唤醒为止。因为它`不需要切换到内核语境`，所以调用一个goroutine比调度一个线程成本低很多。（单个Go程序的调度相对系统级别量少很多）。
    - **GOMAXPROCS**：Go调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。`默认值是机器上的CPU数量`，所以在一个有8个CPU的机器上，调度器会把Go代码同时调度到8个OS线程上。（GOMAXPROCS是m:n调度中的n）正在休眠或者正被通道通信阻塞的goroutine不需要占用线程。阻塞在I/O和其它系统调用中或调用非Go语言写的函数的goroutine需要一个独立的OS线程，但这个线程不计算在GOMAXPROCS内。
        - go 的 goroutins 当 GOMAXPROCS = 1时 goroutines 都是在一个线程上运行，通过不断让出时间片轮流执行（runtime.Gosched()让出时间片）
        - 当一个 goroutine 发生阻塞，go 会将处于同一个系统线程的其它 goroutine 转移到另外一个系统线程上面，以使这些 goroutines 不会阻塞
    - **goroutine没有标识**：

- go扩展包<http://godoc.org>

- 包的查询
    - $go list github.com/go-sql-driver/mysql //判断一个包是否存在于工作空间中
    - $go list ... //用来匹配包的导入路径中的任意字串（导入路径所有可用包）
    - $go list smakry.io/gospace/... //指定的子树的所有包
    - $go list ...xml... //具体的主题可用包
    - $go list -json hash //JSON格式输出每一个包的完整记录

- context 在 goroutines 之间进行信号传递、值传递、设置截止时间（`处于相同进程中的 goroutines`，意味着不能跨进程），通过channel来做到信号同步？

### go test工具

以\_test.go结尾的文件不是go build命令编译的目标，而是go test编译的目标。在\*\_test.go文件中，三种函数需要特殊对待（功能测试函数、基准测试函数、示例函数）。go test工具扫描\*\_test.go文件来寻找特殊函数，并生成一个临时的main包来调用它们，然后编译和运行，并汇报结果，最后清空临时文件。

1. 功能测试函数：以`Test`前缀命名的函数，用来检测一些程序逻辑的正确性（go test运行测试函数）  
2. 基准测试函数：以`Benchmark`开头的函数，用来测试某些操作的性能（go test汇报操作的平均时间）(峰值测试？)  
3. 示例函数：以`Example`开头的函数，用来提供机器检查过的文档（没有参数也没有结果，作为示例文档说明）   

#
- go test -v //选项-v可以输出包中每个测试用例的名称和执行时间
- go test -v -run="French|Non" //选项-run参数是一个正则表达式，匹配的模式函数运行
- go tool cover -html=c.out //测试覆盖率？
- go test -bench=. -benchmen //基准测试，选项-bench指定是基准测试，.表示包中所有的基础测试函数,-benchmen在报告中包含内存分配统计数据
- 性能剖析：通过自动化手段`在程序执行过程中基于一些性能事件的采样`来进行性能评测，然后再从这些采样中推断分析，得到的统计报告就称为性能剖析：
    - CPU性能剖析：识别出执行过程中需要CPU最多的函数，在每个CPU上面执行的线程都每隔几毫秒会定期地被操作系统中断，在每次中断过程中记录一个性能剖析事件，然后恢复正常执行。
    - 堆性能剖析：识别出负责分配最多内存的语句。性能剖析库对协程内部内存分配调用进行采样，因此每个性能剖析事件平均记录了分配的512KB内存
    - 阻塞性能剖析：识别出那些阻塞协程最久的操作，例如系统调用，通道发送和接收数据以及获取锁等，性能分析库在一个goroutine每次被上述操作之一阻塞的时候记录一个事件 


### 变量
- `:=`省略var，左侧没有`声明新的变量`，产生编译错误（常用于初始化声明）

```go
    var intVal int
    intVal := 1 //编译错误intVal不是新的变量
	g,h := 123,"test" //只能在`函数体中`出现
````

- 因式分解关键字写法用于声明全局变量

```go
var(
	a int
	b bool
)
````

- 局部变量声明未使用编译错误，全局变量声明未使用是允许的  


### 常量
- iota常量（可被编译器修改的常量），`const出现iota重置为0`。const`语句块中每行+1`

```go
package main

import "fmt"
const (
    i=1<<iota
    j=3<<iota
    k
    l
)

func main() {
    fmt.Println("i=",i)
    fmt.Println("j=",j)
    fmt.Println("k=",k)
    fmt.Println("l=",l)
}

输出结果：
i=1
j=6
k=12
l=24

//k=3<<iota(1+1) l=3<<iota(1+1+1)
```

- switch

```go
func main() {
	switch {
	case true: //默认true
		fmt.Println("true")
	case false:
		fmt.Println("false")
	default:
		fmt.Println("default")
	}
}
/*输出结果
true
*/
```

```go
func main() {
	switch {
	case false:
		fmt.Println("false 1")
	case true:
		fmt.Println("true 1")
		fallthrough //fallthrough强制执行后面的case内语句不检测case条件
	case false:
		fmt.Println("false 2")
	case true:
		fmt.Println("true 2")
		fallthrough
	case false:
		fmt.Println("false 3")
	default:
		fmt.Println("default")
	}
}
/*输出结果
true 1
false 2
*/
```

### 运算
- go`不支持前++`，i++是一种语句，而非表达式（不同于C族语言，`j = i++ 是不合法的`）

### select语句（随机版通信switch）
- 类似于用于通信的switch语句，`每个case必须是一个通信操作`，要么是发送要么是接收
- select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行，一个默认的（default）子句应该总是可运行的
- `所有channel表达式都会被求值`，Go不会重新对channel或值进行求值
- 如果只某个通信可以进行，它就执行，其它的被忽略
- 如果有多个case都可以运行，select会`随机公平地选出一个执行`，其它不会执行。
- 如果没有任何case可执行：
    - 有default子句，则执行default子句（default必须是可执行的）
    - 没有default子句，`select阻塞`，直到某个通信可以运行，`Go不会重新对channel或值进行求值`

```go
func Chann(ch chan int, stopCh chan bool) {
	var i int
	i = 10
	for j := 0; j < 10; j++ {
		ch <- i
		time.Sleep(time.Second)
	}

	stopCh <- true
}

func main() {
	ch := make(chan int)
	c := 0
	stopCh := make(chan bool)
	go Chann(ch, stopCh)

	for {
		select {
//		case true: //报错，case子句必须是通信操作要么发送要么接收
//			fmt.Println("this is true")
		case c = <- ch:
			fmt.Println("Receive ", c, "channel")
		case s := <- ch:
			fmt.Println("Receive ", s)
		case _ = <- stopCh:
			goto end
		}
	}

end:
}
```

### Go默认的`值传递`，调用过程不会影响到实际参数

### Slice(切片)，即可扩容“动态数组”
````go
var slice []int = make([]int,10) //定义长度10的切片
s := slice[startIndex:endIndex] //复制切片从指定的位置，默认值切片起止位置
````

### Map(集合)

var myMap map[int]string //声明变量，若`无初始化是nil` map不能存放键值对（slice切片也是一样） 
myMap = make(map[int]string) //创建集合，此时才能修改map

### Interface接口（方法的集合）
- 接口`只能定义`方法，具体的由实现接口的类提供
- 定义对象`必须实现`的成员，定义方式同时结构体
- 接口不能直接实例化

### 错误处理
- 实现error接口的错误处理

### 并发、channel

<https://www.jianshu.com/u/947f3ccdd481>
（effect go：https://golang.org/doc/effective_go.html#sharing ）

- Go支持语言并发，通过go关键字开启goroutine
- goroutine轻量级线程，调度由Golang运行时进行管理
- goroutine两个之间传递通过channel（通道）

#### 使用channel还是mutex解决并发？（顺序一致性内存模型（保障事件顺序执行））

1.通过同步原语来给两个事件明确排序：

```go
    func main() {
        done := make(chan int)
        go func() {
            println("hello,world")
            done <- 1
        }()

        <-done // channel取值等待值
    }
```

2.通过sync.Mutex互斥量实现同步：

```go
func main() {
    var mu sync.Mutex
    mu.Lock()
    go func(){
        println("hello,world")
        mu.Unlock()
    }()

    mu.Lock() // 这个必定等待Unlock之后才会执行（sync.Mutex保证），此后main结束，锁GC？
}
```


- channel在`数据流动`中解决并发的优先选择（流动的路径的就是channel，channel两端设计成goroutine）
- mutex数据不动场景，缓存或者状态

### 包和工具

- 正常以“最后一段”作为包名，但有例外：
    - 如果包包含可行的Go程序（比如main函数），那么包名总是main。这是告诉go build的信号，它必须调用连接器生成可执行文件。  
    - \_test.go结尾的测试文件  
    - 有一些依赖管理工具会在包导入路径的尾部追加版本号后缀（如："gopkg.in/yaml.v2",包名不包含后缀，所以包名是yaml） 

- 为了实现reporduceable build（能再生，可再生），`Go1.5`引入了Vendor机制，Go编译器会优先在vendor下搜索依赖的第三方包，这样如果开发者将特定版本的依赖包存放在vendor下面并提交到code repo，那么所有人理论上会等到相同的编译结果，实现reporduceable build。

- 重命名导入（多个包的最后一段是一样的，避免冲突使用重命名）

```go
import (
	"crypto/rand"

	mrand "math/rand" //通过mrand重新命名math/rand包，仅影响当前文件
)
```

- 未使用的导入错误可用空白导入。导入未使用的包的目的，仅仅是为了使用其副作用，对包级别的变量执行初始化表达式求值，并执行它的init函数

```go
imoprt (
	_ "math"
)
```

```go
//database/sql包让用户按需加入想要的数据库驱动程序，应用只需要空白导入所需包
import (
	"database/sql"
	_ "github.com/lib/pg"				//添加Postgres支持
	_ "github.com/go-sql-driver/mysql"	//添加mysql支持
)

db, err = sql.Open("postgres", dbname)	//ok
db, err = sql.Open("mysql", dbname)		//ok
db, err = sql.Open("sqlite3", dbname)	//错误，unknown driver "sqlite3"
```

- Go调用C代码

<https://www.jianshu.com/p/871727c2a82c>

1.为什么调用C代码？  
开源库和性能。

2.C代码写到Go文件中使用注释方式（Go源码中的C代码需要`注释包裹`），最后import ”C“（注意这个语句必须的，且与上面的注释包裹的C代码不能有空行分隔）。编译这种Go文件与正常编译一致，只是实际过程Go调用了名为cgo的工具，cgo识别和读取go源文件中的C元素，并将其提取后交给C编译器编译，最后与go源码编译后的目标文件链接成一个可执行程序。注释包裹的作用就是可以让cgo识别并使用。

```go
package main
 
// #include <stdio.h>
// #include <stdlib.h>
/*
void print(char *str) {
    printf("%s\n", str);
}
*/
import "C"
 
import "unsafe"
 
func main() {
    s := "Hello Cgo"
    cs := C.CString(s)
    C.print(cs) //直接在go中编写了c的print函数
    C.free(unsafe.Pointer(cs))
}
```

3.include头文件、动态链接库的写法（`cgo提供了#cgo指示符指定Go源码在编译后与哪些共享库进行链接`）：  

<https://tonybai.com/2012/09/26/interoperability-between-go-and-c/>

1）使用相对路径： #include "/header/header.h"
2) 使用库地址（在Go中通过cgo LDFLAGS指明lib所在地址，通过CFLAGS指明include所在地址）：  
\#cgo LDFLAGS: -L../../../../../shared/lib/ -lcloud_sdk_api  
\#cgo CFLAGS: -I../../../../../shared/inc/cloud_api/  
\#include "cloud_sdk_server_api.h"  


```go
// #cgo LDFLAGS: -L ./ -lfoo
// #include <stdio.h>
// #include <stdlib.h>
// #include "foo.h"
import "C"
import "fmt“

//以上cgo通过#cgo指示符告诉go编译链接当前目录下的libfoo共享库（我们可以构建共享库foo.h foo.c）

func main() {
    fmt.Println(C.count)
    C.foo()
}
```

3) 文件放到一起： foo.h  foo.c  main.go （里面include "foo.h"即可） 
4) 编译：可以通过设置 CGO_CFLAGS, CGO_CPPFLAGS, CGO_CXXFLAGS, CGO_FFLAGS and CGO_LDFLAGS 环境变量，来设置C的编译参数
5) CGO将当前包引用的C语言符号都放到了虚拟的C包中，同时当前包依赖的其它Go语言包内部可能也通过CGO引入了相似的虚拟C包，但是不同的Go语言包引入的虚拟的C包之前的类型是不能通用的。（不同的Go包，引入的C包是不同的内存空间，对于Go来说就是不同的包空间，以下例子中cgo_helper.C与main.C是不同的，那么mian中调用PrintCString也就不合法了）
6) CGO在两个不同的Go语言包中，存在一个同名的要导出为C语言函数的add()函数，那么在最终的链接阶段将会出现重名的问题（与C转Go不同）。导出文件`为_cgo_export.h文件`，存C源文件要引用需要导出文件导出后才能使用。
7）导出C语言接口时，需要保证函数的参数和返回值类型都是C语言友好的类型，同时`返回值不得直接或间接包含Go语言内存空间的指针`。

8）CGO生成的中间文件的简单示意图。包中有4个go文件，nocgo开头的是没有import "C"指令的非cgo文件，mian.go和hello.go是有import "C"的包含CGO代码的go文件，cgo命令会为每个包含cgo代码的go文件创建2个中间文件（main_cgo1.go main_cgo2.c）(hello_cgo1.go hello_cgo2.c)。然后为整个包创建一个Go文件（\_cgo_gotypes.go），其中包含Go语言部分辅助代码，此外还会创建一个（\_cgo_export.h）文件和一个（\_cgo_export.c）文件，对应Go语言导出到C语言的类型和函数
![cgo生成的中间文件](https://www.processon.com/view/link/5ee9d9a81e085326372faa6e)

```Go
package cgo_helper

//#include<stdio.h>
import "C"

type CChar C.char

func (p *CChar) GoString() string {
    return C.GoString((*C.char)(p))
}

func PrintCString(cs *C.Char) {
    C.puts(cs)
}


package main
//static const char* cs = "hello";
import "C"

import (
    "cgo_helper"
)

func main() {
    cgo_helper.PrintCString(C.cs)
}

```

```go
package main

// static int noreturn(){
//  return 0;
// }
import "C"

import (
    "fmt"
)

func main() {
    v, _ := C.noreturn()
    fmt.Printf("%#T", v) // main._Ctype_int
}

````

9) cgo内存模型：C语言的内存在`分配之后就是稳定的`，但是Go语言函数栈的动态伸缩可能导致栈中内存地址的移动（这是Go和内存模型的最大差异）。因此C访问Go内存空间是不安全的，Go访问C内存空间是安全。在cgo调用的C语言函数返回前，cgo保证传入的go语言内存在此期间不会发生移动，c语言可以大胆的使用go语言的内存（`不过需要小心的是，在取得Go内存后需要马上传入C语言函数，不能保存到临时变量后再间接传入C语言函数。因为cgo只能保证在c函数调用之后被传入的Go语言内存不会反生移动，并不能保证在传入C函数之前内存不发生变化`）。

### 反射

<https://www.jianshu.com/p/b46b1ccd2757>  

1.每个interface变量都有一个对应的pair，pair记录了实际变量的值和类型。一个interface{}类型的变量包含了2个指针，一个指向值的类型，一个指向实际的值（concrete type）。`反射就是用来检测存储在接口变量内部（值value；类型concrete type）pair对的一种机制`。reflect.TypeOf()获取pair中的类型reflect.Type，reflect.ValueOf()获取pair中的值reflect.Value。  

2。也就是说反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种（注意不是Of）。当执行reflect.ValueOf(interface)之后，得到“relfect.Value”变量，可以通过本身的Interface（）方法获得接口变量的真实内容。  
 1）已知原有类型进行“强制转换”为原有真实类型（但需`注意类型要完全符合，当不符合是会出现panic`）。
 realValue := value.Interface().(已知的类型)。
 
 2）未知原有类型，遍历探测其Field。

```go
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    Id   int
    Name string
    Age  int
}

func (u User) ReflectCallFunc() {
    fmt.Println("Allen.Wu ReflectCallFunc")
}

func main() {

    user := User{1, "Allen.Wu", 25}

    DoFiledAndMethod(user)

}

// 通过接口来获取任意参数，然后一一揭晓
func DoFiledAndMethod(input interface{}) {

    getType := reflect.TypeOf(input)
    fmt.Println("get Type is :", getType.Name())

    getValue := reflect.ValueOf(input)
    fmt.Println("get all Fields is:", getValue)

    // 获取方法字段
    // 1. 先获取interface的reflect.Type，然后通过NumField进行遍历
    // 2. 再通过reflect.Type的Field获取其Field
    // 3. 最后通过Field的Interface()得到对应的value
    for i := 0; i < getType.NumField(); i++ {
        field := getType.Field(i)
        value := getValue.Field(i).Interface()
        fmt.Printf("%s: %v = %v\n", field.Name, field.Type, value)
    }

    // 获取方法
    // 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历
    for i := 0; i < getType.NumMethod(); i++ {
        m := getType.Method(i)
        fmt.Printf("%s: %v\n", m.Name, m.Type)
    }
}

运行结果：
get Type is : User
get all Fields is: {1 Allen.Wu 25}
Id: int = 1
Name: string = Allen.Wu
Age: int = 25
ReflectCallFunc: func(main.User)

```

 3)reflect.Value是通过reflect.ValueOf(x)获得的，只有`当x是指针的时候`，才可以通过reflect.Value修改实际变量的值。(reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始值才能修改，当前反射对象是不能修改的)  

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {

    var num float64 = 1.2345
    fmt.Println("old value of pointer:", num)

    // 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值
    pointer := reflect.ValueOf(&num)
    newValue := pointer.Elem()

    fmt.Println("type of pointer:", newValue.Type())
    fmt.Println("settability of pointer:", newValue.CanSet())

    // 重新赋值
    newValue.SetFloat(77)
    fmt.Println("new value of pointer:", num)

    ////////////////////
    // 如果reflect.ValueOf的参数不是指针，会如何？
    pointer = reflect.ValueOf(num)
    //newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”
}

运行结果：
old value of pointer: 1.2345
type of pointer: float64
settability of pointer: true
new value of pointer: 77

```

3.Go reflect慢主要有2个原因：  
 1）涉及到内存分配以及后续的GC。
 2）reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。


- reflect.TypeOf函数接受任何的interface{}参数，并把接口中的`动态类型`以reflect.Type形式返回
- reflect.ValueOf函数接受任意类型的interface{}并将接口的`动态值`以reflect.Value形式返回
- 调用Value的Type方法会把它的类型以reflect.Type方式返回

```go
func main() {
	t := reflect.TypeOf(3)
	fmt.Println(t.String()) //int
	fmt.Println(t) //int
	var w io.Writer = os.Stdout
	fmt.Println(reflect.TypeOf(w)) //*os.File

	v := reflect.ValueOf(3)
	fmt.Println(v) //3
	fmt.Printf("%v\n", v) //3
	fmt.Println(v.String()) //<int Value>
	fmt.Println(v.Type()) //int

	x := v.Interface() //reflect.ValueOf的逆操作，返回interface{}接口值
	i := x.(int)
	fmt.Printf("%d\n", i)
}
```

- 深度相等：包reflect中的DeepEqual函数用来报告2个`变量的值`是否“深度”相等。DeepEqual函数对基本类型使用内置的==操作符进行比较，对于组合类型它逐层深入比较相应的元素（递归）。

### 低级编程

- 函数unsafe.Sizeof同c的sizeof返回参数在内存中占用的字节长度

```go
import (
	"fmt"
	"unsafe"
)

func main() {
	fmt.Println(unsafe.Sizeof(float64(0)))
}
```

- 为了可移植性，将以字来表示引用类型的长度。`在32位操作系统上，字的长度是4个字节，在64位系统上，字的长度是8个字节。`（内存对齐问题？）

类型								|大小
bool							|1个字节
intN、uintN、floatN、complexN	|N/8字节（例如float64是8字节，此处是字节）
int、uint、uintptr				|1个字
*T								|1个字
string							|2个字（数据、长度）
[]T								|3个字（数据、长度、容量）
map								|1个字
func							|1个字
chan							|1个字
interface						|2个字（类型、值）

- 语言规范并没有要求成员声明的顺序对应内存中的布局顺序，理论上编译器可以自由安排。但正常不这样做，如果结构体成员的类型是不同的，那么将存在相同类型的成员定义在一起可以更节约内存空间。例如下面三个结构体成员相同但内存占用不同（内存对齐）：

定义								| 64位	|32位
struct{ bool; float64; int16 }	|3个字	|4个字
struct{ float64; int16; bool }	|2个字	|3个字
struct{ bool; int16; float64 }	|2个字	|3个字

- unsace.Alignof报告它参数类型所要求的对齐方式。和Sizeof一样，它的参数可以是任意类型的表达式，并且返回一个常量。典型地，布尔类型和数值类型对齐到它们的长度（最大8个字节），而其他的类型则按字对齐

```go
type TypeNew struct {
	b	bool
	f	float64
	i	int
}

func main() {
	a := TypeNew{false, 10.0, 0}
	fmt.Println(unsafe.Alignof(a)) //8
}
```

- unsafe.Offsetof计算成员f相对于结构体x起始地址的偏移值，如果有内存空位也计算在内，该函数的操作数必须是一个成员选择器x.f

```go
type TypeNew struct {
	b	bool
	f	float64
	i	int
}

func main() {
	a := TypeNew{false, 10.0, 0}
	fmt.Println(unsafe.Offsetof(a.i)) //16
}

```

- unsafe.Pointer类型指针可以存储任何变量的地址。`但无法间接地通过一个unsafe.Pointer变量使用*p`（uintptr也可以表示任何地址，但uintptr可以间接的访问*p，因为保存了指针指向地址的数值），因为不知道这个表达式的具体类型。一个普通的指针 *T可以转换为unsafe.Pointer类型的指针，另外一个unsafe.Pointer类型的指针也可以转换回普通指针，而且可以不必和原来的类型*T相同。例如通过转换一个*float64类型的指针到*uint64类型

```go
func Float64bites(f float64) uint64 {
	return *(*uint64)(unsafe.Pointer(&f))
}
fmt.Printf("%#016x\n", Float64bites(1.0)) //0x3ff0000000000000
```

- 移动的垃圾回收器

```go
var x struct {
	a	bool
	b	int16
	c	[]int
}

pb := (*int16)(unsafe.Pinter(uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)))
*pb = 42
fmt.Println(x.b) //42

//以下的方式错误，移动垃圾回收，导致tmp可能已经不是原始的&x
tmp := uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)
pb :=  (*int16)(unsafe.Pointer(tmp))
*pb = 42
```

golang中的三个指针类型
其实指针有三种：
一种是我们常见的*，用*去表示的指针；
一种是unsafe.Pointer，Pointer是unsafe包下的一个类型；
最后一种是uintptr，uintptr 这玩意是可以进行运算的也就是可以++–；

他们之间有这样的转换关系：
\*<=> unsafe.Pointer <=> uintptr
有一点要注意的是，uintptr 并没有指针的语义，意思就是 uintptr 所指向的对象会被 gc 无情地回收。而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收.

```go
func main() {
    s := make([]int, 10)
    s[1] = 2
    
    p := &s[0]
    fmt.Println(*p)
    
    up := uintptr(unsafe.Pointer(p)) //这里有可能会被回收 所以最好写成 (*int)unsafe.Pointer（uintptr(unsafe.Pointer(p))+unsafe.Sizeof(int(0))）
    up += unsafe.Sizeof(int(0)) // 这里不是up++

    p2 := (*int)(unsafe.Pointer(up))
    fmt.Println(*p2)
}
```


#### Go判断结构体是否实现了指定接口

在go中想知道某个结构体（有人称为类）是否实现了某个接口类型，如下例子：  

```go
type IFace interface {
    Eat() string
}

type Bird struct {
    Eyes   string
    Color  int
}

//要判断Bird是否实现了接口IFace做法
var _ IFace = new(Bird) //定义变量类型是IFace，直接具体Bird给IFace赋值

//或

var _ IFace = (*Bird)(nil) //同样的方式，但这种方式不需要分配内存空间，上一种需要
```

#### GO随手笔记

##### Timer、Ticker

Timer：定时器，是到固定时间后会执行一次  
Ticker：间隔循环定时器，只要定义完成，马上执行一次，后每隔固定时间都会执行  

Timer要做到Ticker效果需要在Timer执行后Reset来重新开始Timer  

<https://blog.csdn.net/busai2/article/details/82503699>

```go
package main

import (
    "time"
)

func main() {
    iAdd := time.Duration(1)
    timer1 := time.NewTimer(iAdd * time.Second)
    go func(t *time.Timer) {
        for {
            res := <-t.C
            fmt.Println(res)
            iAdd++
            t.Reset(iAdd * time.Second)
        }
    }(timer1)

    time.Sleep(15 * time.Second)
}

```

##### 发布/订阅模式
```go 
package main

import (
    "fmt"
    "strings"
    "sync"
    "time"
)

type (
    subscriber chan interface{}         // 订阅者为一个通道
    topicFunc  func(v interface{}) bool // 主题为一个过滤器
)

// 发布者对象
type Publisher struct {
    m          sync.RWMutex
    buffer     int
    timeout    time.Duration            // 发布超时时间
    subsribers map[subscriber]topicFunc // 订阅者信息
}

// 构建一个发布者对象，可以设置发布超时时间和缓存队列的长度
func NewPublisher(publishTimeout time.Duration, buffer int) *Publisher {
    return &Publisher{
        buffer:     buffer,
        timeout:    publishTimeout,
        subsribers: make(map[subscriber]topicFunc),
    }
}

// 添加一个新的订阅者，订阅全部主题
func (p *Publisher) Subscirbe() chan interface{} {
    return p.SubscribeTopic(nil)
}

// 添加一个新的订阅者，订阅过滤器筛选后的主题
func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} {
    ch := make(chan interface{}, p.buffer)
    p.m.Lock()
    p.subsribers[ch] = topic
    p.m.Unlock()
    return ch
}

// 退出订阅
func (p *Publisher) Evict(sub chan interface{}) {
    p.m.Lock()
    defer p.m.Unlock()

    delete(p.subsribers, sub)
    close(sub)
}

// 发布一个主题
func (p *Publisher) Publish(v interface{}) {
    p.m.RLock()
    defer p.m.RUnlock()

    var wg sync.WaitGroup
    for sub, topic := range p.subsribers {
        wg.Add(1)
        go p.sendTopic(sub, topic, v, &wg)
    }

    wg.Wait()
}

// 发送主题，可以容忍一定的超时
func (p *Publisher) sendTopic(sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup) {
    defer wg.Done()

    if topic != nil && !topic(v) {
        return
    }

    select {
    case sub <- v:
    case <-time.After(p.timeout):
    }
}

// 关闭发布者对象，同时关闭所有的订阅者通道
func (p *Publisher) Close() {
    p.m.Lock()
    defer p.m.Unlock()

    for sub := range p.subsribers {
        delete(p.subsribers, sub)
        close(sub)
    }
}

func main() {
    p := NewPublisher(100*time.Millisecond, 10)
    defer p.Close()

    all := p.Subscirbe()
    golang := p.SubscribeTopic(func(v interface{}) bool {
        if s, ok := v.(string); ok {
            return strings.Contains(s, "golang")
        }

        return false
    })

    p.Publish("hello world")
    p.Publish("hello golang!")
    go func() {
        for msg := range all {
            fmt.Println("all:", msg)
        }
    }()

    go func() {
        for msg := range golang {
            fmt.Println("golang:", msg)
        }
    }()

    time.Sleep(3 * time.Second)
}

```

#### 原子性操作 atomic

一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为原子性（atomicity），原子操作是无锁的，通过CPU指令直接实现， 其它同步技术常常依赖于原子操作 。

`Mutex`由`操作系统`实现，而`atomic`包中的原子操作则由`底层硬件`直接提供支持。在CPU实现的指令集里，有一些指令被封装进了atomic包，这些指令在执行的过程中是不允许中断（interrupt）的，
因此原子操作可以在`lock-free`的情况下保证并发安全，并且它的性能也能做到随CPU个数的增多而线性扩展。

<https://studygolang.com/articles/23242?fr=sidebar>

#### 性能分析，死锁分析

runtime/pprof

eg:
go tool pprof http://0.0.0.0:63603/debug/pprof/heap
 
web直接打开  http://0.0.0.0:63603/debug/pprof

<https://www.jianshu.com/p/162f44022eb7>
<https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/>