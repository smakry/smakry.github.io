---
layout: post
title: 'Golang'
date: 2019-09-09
author: smakry
tags: GO 阅读笔记
---

> 简洁、快速、安全

> 并行、有趣、开源
 
> 内存管理、数组安全、编译迅速

## Go笔记

Go强类型化的语言，具有垃圾回收机制，并显示支持并编程，Go原生地支持Unicode，可以处理所有国家的语言  
<https://github.com/golang/go/wiki/NonEnglish>  

- GOPATH目录可以是任意的，唯一的要求是`不能是你安装Go的目录`  
<https://go-zh.org/doc/code.html>  

- linux下git  
<https://blog.csdn.net/qq_42303254/article/details/89230332>

go游戏框架  
<https://github.com/liangdas/mqant/wiki>

- import “()”里的导入顺序最终会被gofmt工具按照字母顺序表进行排序  
- range产生键值对，当不使用其中的键或者值要用"_"下划线表示（空标识符），Go不允许存在无用的临时变量  
- range的for循环迭代顺序是随机（无序的）  
- 格式化类型verb（动词），下表不完整还有更多  
verb | 描述
%d 		 |十进制整数  
%x,%o,%b |十六进制，八进制，二进制数  
%f,%g,%e |浮点数：如3.141593，3.141592653589793，3.141593e+00  
%t		 |布尔型：true或者false  
%c		 |字符（Unicode码点）  
%s		 |字符串  
%q		 |带引号字符串（如"ABC"）或者字符（如'C'）  
%v		 |内置格式的任何值  
%T		 |任何值的类型  
%p		 |指针，十六进制表示，前缀0x  
%%		 |百分号本身（无操作数）  

-go关键字
break	|default	|func	|interface	|select	  
case	|defer		|go		|map		|struct  
chan	|else		|goto	|package	|switch  
const	|fallthrough|if		|range		|type  
continue|for		|import	|return		|var  

- 内置的预声明的常量、类型和函数  
常量：true	false	iota	nil  

类型：（byte=uint8，rune=int32）  
int		|int8	|int16		|int32	|int64  
uint	|uint8	|uint16		|uint32	|uint64	|uintptr  
float32	|float64|complex64	|complex128  
bool	|byte	|rune		|string	|error  

函数：  
make	|len	|cap	|**new**	|append	|copy	|close	|delete	  
complex	|real	|imag	|panic	|recover  

- 包里函数外的全局函数，`大写开头的函数其它包可见`（导出的，type类型同规则），包名总是小写字母组成  
- 函数调用可在声明之前，函数和其它`包级别`的实体可以以`任意次序`声明（变量类似）  

```go
//包级别
var a = b + c //包级别的这种方式是正确的，最后a = 3
var b = 1
var c = 2

```  
- map是一个使用make创建的数据结构的`引用`（变量别名）  
- GO有escape analysis，在编译期，它会分析你的变量是否在函数执行完毕那一刻，程序有没有可能有别的对象引用到它（所谓逃逸，`逃逸的在堆上分配`），如果没有，那这个变量就可以在栈上分配，完全不经过gc。如果它已经逃逸了，那什么时候gc就由不得你了。(go build 加上-gcflags='-m'会显示escape内容)<https://blog.csdn.net/weixin_42117918/article/details/82024667>
    - 对于`包一级声明的变量`来说，它们的`生命周期和整个程序的运行周期一致`；
    - 而`局部变量`生命周期则是`动态`的：每次从创建一个新变量的声明语句开始，直到该变量`不再被引用为止`(不可访问)，然后变量的存储空间`可能`被回收。
- 字符串变量声明方式  
- 初始值对于类型的零值（数值是0；布尔值是false；字符串是""；对于接口和引用类型（slice、指针、map、通道、函数）是nil；对于像数组或结构体这样的符合类型，零值是其所有元素或成员的零值），go里面不存在未初始化变量    
- doc.go文件对包的文档注释

```go
s := "" //常用于函数内局部变量（常用）  
var s string //常用于包内，默认初始化""（常用）
var s = "" //由初值判定类型
var s string = "" //显示变量类型
```

- func (t Time) Second() int{} //Time类型的一个方法Second()  
- 当一个goroutine试图在一个通道上进行发送或者接收操作时，它会`阻塞`，直到另一个goruntine试图进行接收或者发送操作才传递值（读写锁？）  
- switch中case从上到下推演，但是default可以放到任何位置  
- go`指针不支持算术运算`  
- 额外的bool结果：  
v,ok = m[key] //map查询  
v,ok = x.(T) //类型断言  
v,ok = <-ch //通道接收  

- T(x)`将值x转成T类型`，T类型与x具有相同的底层类型或者二者都指向相同底层类型的未命名指针则二者可以转换；通过==和<等
- 操作符，命名类型（type的类型）的值可以与其相同类型的值或者底层类型相同的未命名类型的值相比较，但是不同命名类型的值不能直接比较：  

```go
type TypeA float64
type TypeB float64

var a TypeA
var b TypeB
var c TypeA
fmt.Println(a == b) //编译错误，不同的命名类型
fmt.Println(a == 0) //true（a类型转换int(a)，底层类型变成int与0的底层类型相同）
fmt.Println(a == c) //true相同的命名类型
```  

- 包初始化？？？
- 作用域问题（同样规则运用于switch）：  

```go
func f()int{
    return 15;
}

func main(){
    if x := f();x < 10 {
        fmt.Printf("xx")
    } else if x < 15 { //x也在作用域内

        fmt.Printf("%d",x)
    } else {
        fmt.Printf("world:%d",x)
    }

    fmt.Printf("world:%d",x) //此处x是未定义，不在作用域内
}

```

- int不等同于int32，uint不等同uint32（在特定平台是相等的，或者是该平台上的运算效率最高的值，但不同硬件平台或者不同编译器大小是不一定的）
- go中取模余数的正负号总是与被除数一致（-5%3和-5%-3都是-2）  
- &^操作符，按位将右边二进制1的位在左边出现的置0   
- 十进制下，float32有效小数大约6位，float64小数大约15位。绝大多数情况下应优先选用float64，float32能精确表示的正整数范围有限：  

```go
var f float32 = 16777211
fmt.Println(f == f + 1)  //结果false

var f2 float32 = 1 << 24 //只能精确到1<<24
fmt.Println(f2 == f2 + 1) //结果true  

nan := math.NaN()
fmt.Println(nan == nan,nan < nan,nan > nan) //"false false false"比较总是不成立
```

- go的bool值只有true和false，0和1不能隐式转成false和true，反之也不行  
- 字符串可以追加`不能修改`如 s := "left foot" 可以 s += ",right foot" 但s[0] = 'L'编译错误。不能重赋值，代表原始串的字串可以共用原始串的内存地址（不需要重新分配内存） 
- Printf格式化字符含多个%谓词，原本要求提供相应数量的操作数，而%后的副词[1]告知Printf重复使用第1个操作数，其次副词#告知Printf输出相应的前缀  

```go
o := 0666
fmt.Printf("%d %#o %#[2]x\n",o,o) //重复使用第2个操作数
```  

- go源文件总是UTF-8编码（变长编码）。\uhhhh表示16位码点值，\Uhhhhhhhh表示32位码点值，每个h表示一个十六进制数字。码点值`小于256`的可用单个十六进制数转义如'A'写成'\x41'`更高的需要用\u或\U`转义，\x会存在不合法的文字符号。UTF-8解码器读入一个不合理的字节，无论显示调用utf8.DecodeRuneInString还是range循环内隐式读取，都会产生一个专门的Unicode字符'\uFFFD',输出类似�，表示上游处理文字编码存在瑕疵。

```go
	s := "Hello, 世界"

	fmt.Println(len(s))
	fmt.Println(utf8.RuneCountInString(s))
	
	for i := 0; i < len(s);{
		r,size := utf8.DecodeRuneInString(s[i:])
		fmt.Printf("%d\t%c\n",i,r)
		i += size //索引需根据具体的字符占用字节计算
	}
/*输出结果
13
9
0	H
1	e
2	l
3	l
4	o
5	,
6	 
7	世
10	界
*/

	for i,r := range s {
		fmt.Printf("%d\t%q\t%d\n",i,r,r)
	}
/*输出结果
0	'H'	72
1	'e'	101
2	'l'	108
3	'l'	108
4	'o'	111
5	','	44
6	' '	32
7	'世'	19990
10	'界'	30028 //返回的索引直接字符的起始索引
*/

```

- const iota = 0 // Untyped int  

```go
const(
	_ = 1  << (10 * iota)
	KiB // 1024 (1 << (10 * 1))
	MiB // 1048576
	GiB // 1073741824
	TiB // 1099511627776
	PiB // 1125899906842624
	EiB // 1152921504606846976
	ZiB // 1180591620717411303424
	YiB // 1208925819614629174706176
)
```  

- init执行顺序根据import然后再当前包按顺序（当前包可以有多个init）  
- tree dir (linux查看dir的目录树，省略dir即当前目录)  
- 函数调用，参数都会创建一个副本（不同于其它语言的引用），这样就会拷贝一次值（`指针、slice、map函数和通道channel也是值拷贝`，只是包含了引用类型或者是可以通过包含的类型修改实参值。例如slice包含指向底层数组的指针，这就能改变到底层数组）
- q := [...]int{1,2,3}省略号“...”出现在数组长度的位置，表示输出长度由初始化的元素个数决定    
- r := [...]int{9:-1} 定义10个数据，最后一个数据的值是-1，其余默认值0。由最大的index决定
- 数组是可以比较（`数据类型`跟`元素个数`一致的情况下才能比较，比较的是元素值。不同类型或不同元素个数比较会编译错误）  
- 切片slice有3个属性指针、长度和容量。（切片，即可视作是数组的一个`子片的引用`）
    - 指针是指向该切片的第1个元素（`并非底层的数组的首元素`）
    - 长度是指slice中元素个数，不能超过slice的容量，内置函数len获取
    - 容量即切片的起始位置到底层数组的最后一个元素间元素个数，内置函数cap获取
    - s := []int{0,1,2}与 s := [...]int{0,1,2}注意二者区别`[]表示切片`，`[...]表示的是数组`类型不同；`切片不能通过==等来比较`，标准库有bytes.Equal来比较字节切片（[]byte）,其余的比较需自己实现   
    - 判断slice是不是为空不能用== nil因为 s = []int{}用== nil返回是false但实际是空，需用len() == 0判定  
    - make([]T,len,cap) 和make([]T,cap)[:len]二者等价（注意cap位置）  
    - append方式类似c++中verctor的动态扩容方式（`内存地址变化了`）  

```go
arr := [...]string{"Sunday","Monday","Tuesday","Wednesday","Thursday","Firday","Saturday","",""}

work := arr[1:5]

fmt.Println(work[0],len(work),cap(work))
fmt.Printf("%T\n",work)

/*输出
Monday 4 8
[]string
*/

//上面的基础
day := work[:10] //day切片引用从work切片的第1个元素"Monday"后10个，报错超出了work切片的容量8（可以理解原始的容量不足以作为day的引用）

fmt.Println(len(day),cap(day)) //报错
```


- slice作为函数参数是值传递,但可通过切片的底层数组地址进行修改原始数组，但当切片容量长度发生变化就有差别（修改函数外的切片，可通过返回新的切片赋值或者传递指针） 

```go
func main(){
    s1 := []int{1,2,3,4,5,6,7}

	s1 = append(s1[:3],s1[4:]...) //切片s1重新赋值只有原始切片的6个长度
	fmt.Printf("%d,%d,%d,%p\n",s1,len(s1),cap(s1),s1) //[1 2 3 5 6 7],6,7,0xc00001e080
}

```

```go
func test(slice []int) {
    slice = append(slice[:3],slice[4:]...) //未超出底层数组的长度，没有重新内存分配
}

func main(){
    s1 := []int{1,2,3,4,5,6,7}

    test(s1) //test没有重新分配内存，修改到了原始数组，
			//但是s1在test之外并没有变化，还是指向原始的切片,所以切片还是长度7，2个元素7
    fmt.Printf("%d,%d,%d,%p\n",s1,len(s1),cap(s1),s1) //[1 2 3 5 6 7 7],7,7,0xc00001e080
}

```  

```go
func test(slice []int) {
    slice = append(slice[:3],slice[1:]...) //超出底层数组的长度，重新内存分配
}

func main(){
    s1 := []int{1,2,3,4,5,6,7}

    test(s1) //test重新分配内存，没有修改到了原始数组，
			//但是s1在test之外并没有变化，还是指向原始的切片,所以切片还是长度7
    fmt.Printf("%d,%d,%d,%p\n",s1,len(s1),cap(s1),s1) //[1 2 3 4 5 6 7],7,7,0xc00001e080

}

```

- map
    - map的`键类型必须是可以通过操作符==来进行比较的数据类型`，虽然浮点型可以，但是浮点存在数据有效范围如float32只能精确到1<<24。
    - map中ages["bob"] = ages["bob"] + 1 //当键bob不在map中，这是安全的，`键不存在查找返回的是类型的零值`
    - map`元素`不是一个变量（map类型本身是一个变量），不可以获取它的地址如 _ = &ages["bob"] //编译错误  
    - map中元素迭代是顺序是随机的，取决于散列算法，若需要有序迭代，需通过排序key  


```go
var graph = make(map[string]map[string]bool) //map的元素是map

func addEdge(from,to string) {
    edges := graph[from]
    if edges == nil {
        edges = make(map[string]bool)
        graph[from] = edges
    }
    edges[to] = true
}

func hasEdge(from,to string) bool {
    return graph[from][to] //当from跟to都不存在的时候，这个调用依然是安全的（键不存在查找返回的是类型零值）
}

fmt.Printf("%T,%[1]q,%T",graph["sdf"],graph["sdf"]["ssss"]) //结果：map[string]bool,map[],bool

```

- linux结束符ctrl + d

- 结构体
    - 结构体是否能比较取决于结构体成员变量是否都能够比较
    - 结构体的匿名成员变量（只需要指定变量类型，不需要显示的指定变量名称），访问成员时可以直接通过一级的索引访问（匿名看做把成员变量的成员变量全部提升一级到结构体中，`展开`）；匿名成员有隐式的名字所以`不能同时存在2个相同类型的匿名变量`（冲突了都指向同一个）  
    - 结构体类型可导出，结构体匿名成员若是不可导出的（小写开头），那么引用包不能通过.成员变量的方式访问（因为成员是不可导出），但是可通过匿名的方式访问（因为结构体本身是可导出的，展开就能访问到）

```go
type Point struct{
	X,Y int
}

type Circle struct{
	Point //只指定了Point类型没有实际的名称，此时就相当于展开Point类型,但也可以通过类型访问
	Radius int
}

var c Circle
c.X = 10 //匿名展开
c.Point.X = 10 //匿名未展开，2种方式是一致的
```

- vim多行注释，查找替换  
:20,30 s/^/#/g 第20到30行用 # 注释掉。  
:20,30 s/^#//g 取消注释  
:4,10 s/^[^I ]\+// 去掉行首的空白字符  
用 . 表示当前行。  
:.,30 s/^/#/g  
/string （sting为查找对象）正向查找  
？string 反向查找  
：m,n> 向右移动一个tab  
：m,n< 向左移动一个tab  
vim ~/.vimrc  当前用户vim配置  
vim /etc/vim/vimrc 系统vim配置  

- json
    - func Marshal(v interface{}) ([]byte, error) //go类型转成json
    - func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) //按照格式转成json
    - func Unmarshal(data []byte, v interface{}) error //json转成go类型  
    - `成员标签定义`（转成json后，成员对应转化）  

```go
package main

import(
    "fmt"
    "encoding/json"
    "log"
)

type Movie struct {
    Title   string
    Year    int     `json:"released,string"` //成员标签定义，Year字段用released替换，且类型替换为string
    Color   bool    `json:"color,omitempty"` //成员标签定义，Color字段用color替换，omitempty表示bool类型可以忽略空
    Actors  []string
}

func main(){
    var movies = []Movie{
        {Title:"t1",Year:1854,Color:false,
            Actors:[]string{"Husdf","fsdfs"}},
        {Title:"t2",Year:1842,Color:true,
            Actors:[]string{"Husdf","fsdfs"}},
        {Title:"t3",Year:1842,Color:false,
            Actors:[]string{"Husdf","fsdfs"}},
    }

    data,err := json.MarshalIndent(movies,"","  ")
    if err != nil {
        log.Fatalf("sfderro")
    }

    fmt.Printf("%s\n",data)
}

```

- 格式化输出文本模板和HTML模板（以下是文本模板，HTML同样是格式化为可解析html的）,html模板可用来防止注入攻击（按照格式化生成，防止重新解析）

```go
package main

import(
    "fmt"
    "encoding/json"
    "net/http"
    "net/url"
    "strings"
    "time"
    "text/template"
    "log"
    "os"
)

const IssuesURL = "https://api.github.com/search/issues"

//注意printf后有空格，使用的是“`”不是单引号
const temp1 = `{{.TotalCount}} issues:
{{range.Items}}------------------------
Number: {{.Number}}
User:   {{.User.Login}}
Title:  {{.Title | printf "%.64s"}}
Age:    {{.CreatedAt | daysAgo}} days
{{end}}`

var mytmp = template.Must(template.New("report").Funcs(template.FuncMap{"daysAgo" : daysAgo}).Parse(temp1))

type IssuesSearchResult struct {
    TotalCount  int `json:"total_count"`
    Items       []*Issue
}

type Issue struct {
    Number      int
    HTMLURL     string `json:"html_url"`
    Title       string
    State       string
    User        *User
    CreatedAt   time.Time `json:"created_at"`
    Body        string
}

type User struct {
    Login   string
    HTMLURL string `json:"html_url"`
}

func daysAgo(t time.Time) int {
    return int(time.Since(t).Hours() / 24)
}

func SearchIssues(terms []string)(*IssuesSearchResult,error) {
    q := url.QueryEscape(strings.Join(terms," "))
    resp,err := http.Get(IssuesURL + "?q=" + q)
    if err != nil {
        return nil,err
    }

    if resp.StatusCode != http.StatusOK {
        resp.Body.Close()
        return nil,fmt.Errorf("search query failed:%s",resp.Status)
    }

    var result IssuesSearchResult
    if err := json.NewDecoder(resp.Body).Decode(&result);err != nil {
        resp.Body.Close()
        return nil,err
    }

    resp.Body.Close()
    return &result,nil
}

func main() {
    str := []string{"repo:golang/go is:open json decoder"}
    if res,ok := SearchIssues(str);ok == nil {
        err := mytmp.Execute(os.Stdout,res)
        if err != nil {
            log.Fatalf("execution: %s",err)
        }
    }
}

```

```go
var data struct {
	A	string			//不受信任的纯文本
	B	template.HTML	//受信任的HTML（在template/content.go中命名的字符串类型）
}
```
- 以下形式的函数定义注意返回值括号变量名类型（直接声明了一个返回值变量类型）,可以直接返回(return必须)  

```go
func add(x int) (z int) {
    z = x + x //此处z已经在返回值声明了，不能再声明为一个新的变量
    return
}
```

- go函数参数是`没有默认参数`的
- func Sin(x float64) float64 //没有函数体，说明这个函数使用的GO以外的语言实现，这是声明定义了该函数的签名，此处Sin使用汇编语言实现

- golang.org/x/net 安装方法
为了使包的导入方式不变，我们需要在src目录下面构造目录结构  
$mkdir -p $GOPATH/src/golang.org/x/  
$cd $GOPATH/src/golang.org/x/  
$git clone https://github.com/golang/net.git net  
$go install net  

- 遍历HTML树  

```go
package main

import(
    "fmt"
    "os"
    "net/http"

    "golang.org/x/net/html"
)

//golang.org/x/net/html定义的Node节点类型
type Node struct {
    Type                    NodeType
    Data                    string
    Attr                    []Attribute
    FirstChild,NextSibling  *Node
}

type NodeType int32

const (
    ErrorNode NodeType = iota
    TextNode
    DocumentNode
    ElementNode
    CommentNode
    DoctypeNode
)

type Attribute struct {
    Key,Val string
}

//遍历属性标签a超链接href的地址
func visit(links []string,n *html.Node) []string {
    if n.Type == html.ElementNode && n.Data == "a" {
        for _,a := range n.Attr {
            if a.Key == "href" {
                links = append(links,a.Val)
            }
        }
    }

    for c := n.FirstChild;c != nil;c = c.NextSibling {
        links = visit(links,c)
    }

    return links
}

//遍历节点标签
func outline(stack []string,n *html.Node) {
    if n.Type == html.ElementNode {
        stack = append(stack, n.Data)
        fmt.Println(stack)
    }

    for c := n.FirstChild; c != nil; c = c.NextSibling {
        outline(stack,c)
    }
}

func main(){
    url := "https://github.com/smakry"
    resp,err := http.Get(url)
    if err != nil {
        fmt.Fprintf(os.Stderr,"fetch err:%v\n",err)
        os.Exit(1)
    }

    doc,err := html.Parse(resp.Body)
    resp.Body.Close()
    if err != nil {
        fmt.Fprintf(os.Stderr,"err:%s\n",err)
        os.Exit(1)
    }

    //outline(nil,doc)

	for _, link := range visit(nil, doc) {
		fmt.Println(link)
	}
}

```

- Go的函数调用栈不同于其它语言的大小在64kb到2MB之间，`Go实现可变长的栈`，随使用而增长，可达到1GB左右的上限
- Go语言的垃圾回收机制将回收未使用的内存，但不能指望它会释放未使用的操作系统资源，比如打开的文件已经网络连接，必须下显示地关闭它们  

- 匿名函数  

```go
func test() func() int {
    var x int
    return func () int {
        x++
        return x * x
    }
}

func main(){
    fn := test() //fn保存的是匿名函数func() int {x++ return x * x}地址，所以x变量对于fn是外部变量

    fmt.Println(fn()) //1
    fmt.Println(fn()) //4
    fmt.Println(test()()) //1
    fmt.Println(test()()) //1
}

```

- 匿名函数需要进行递归，必须先声明一个变量然后将匿名函数赋给这个变量。如果将两个步骤合并成一个声明，函数字面量将不能存在于visitAll变量的作用域中，这样也就不能递归地调用自己（`如果定义一句的话，就是先有匿名函数本体，才有变量visitAll`，如果是先声明变量，那是先有变量visitAll匿名函数内部就能看到visitAll这个变量）  

```go
//深度遍历拓扑图
package main

import(
    "fmt"
    "sort"
)

var prereqs = map[string][]string {
    "algorithms":{"data structures"},
    "calcules":{"linear algebra"},
    "compilers":{
        "data structures",
        "formal languages",
        "computer organization",
    },
    "data structures":{"discreate math"},
    "databases":{"data structures"},
}

func topoSort(m map[string][]string) []string {
    var order []string
    seen := make(map[string]bool)
    var visitAll func(items []string)
    visitAll = func(items []string) {
        for _, item := range items {
            if !seen[item] {
                seen[item] = true
                visitAll(m[item])
                order = append(order, item)
            }
        }
    }

    var keys []string
    for key := range m {
        keys = append(keys, key)
    }
    sort.Strings(keys) //未sort顺序是随机的
    visitAll(keys)
    return order
}

func main(){
    for i, course := range topoSort(prereqs) {
        fmt.Printf("%d:\t%s\n", i + 1, course)
    }
}

```

- 捕获迭代变量（迭代变量的内存地址是一致的），通过创建临时变量（每次`迭代都重新分配了地址空间`）  
  
```go
func main(){
    arry := []string{"1","2","4","5","6","7"}

    var temp []string
    for _, v := range arry {
        dir := v //临时变量dir地址是不同的，而迭代变量v地址是一致的
        fmt.Printf("%p,%p\n",&v,&dir)
        temp = append(temp, v)
    }

    fmt.Println(temp)
}

/*输出结果：
0xc000010200,0xc000010210
0xc000010200,0xc000010230
0xc000010200,0xc000010240
0xc000010200,0xc000010250
0xc000010200,0xc000010260
0xc000010200,0xc000010270
[1 2 4 5 6 7]
*/
``` 

- 变长函数的类型（参数可变长）和一个带有普通slice参数的函数类型不相同
    - func f(...int) {} //变长函数（注意省略号位置）,类型是func(...int)   
    - func g([]int) {} //类型是func([]int)  

- defer语句函数或者方法延迟调用。在调用之前加上关键字defer，参数为当前defer调用时候的值，defer的执行被推迟到`包含defer语句函数执行结束之后才被执行到`（return之后，那么可以操作到返回值），且`按照调用defer语句顺序的倒叙执行`（defer调用入栈（参数也入栈），直到当前函数执行结束再从栈取出执行？）。在许多文件系统中，尤其是NFS，`写错误推迟到了文件关闭的时候`，所以如果文件关闭是延迟调用的话，最后文件操作失败会导致数据丢失。  

```go
func test(i int) {
    fmt.Println("call:",i)
}

func main(){
    var a int = 1
    a++
    fmt.Println(a)
    defer test(a + 11)
    a++
    fmt.Println(a)
    defer test(a + 22)
}

/*输出结果
2
3
call: 25
call: 13
*/
```

```go
//defer用于调试
func test(msg string) func() {
    start := time.Now()
    log.Printf("enter %s", msg)
    return func() {
        log.Printf("exit %s (%s)\n", msg, time.Since(start))
    }
}

func main(){
    defer test("main")() //注意这里的()不能少，相当于先调用test("main")，再延迟调用返回的匿名函数
    time.Sleep(2 * time.Second)
}

```

```go
func test(i int) (res int) {
    defer func(){ res += i}() //defer调用可以操作到最后的返回值res，因为defer在return之后执行
    return i + i
}

func main(){
    fmt.Println(test(2)) //6
}

```

- Go的宕机机制让`延迟执行的函数在栈清理之前调用`（可用延迟函数转移堆栈信息用于排查）；defer panic recover构成异常处理机制。`利用recover处理panic指令，defer必须在panic之前声明，否则当panic时，recover无法捕获到panic`    
<https://www.jianshu.com/p/0cbc97bd33fb> 

```go
package main

import(
    "fmt"
    "runtime"
)

func f(x int) {
    fmt.Printf("f(%d)\n", x + 0 / x)
    defer fmt.Printf("defer %d\n", x)
    f(x - 1)
}

func printStack() {
    var buf [4096]byte
    n := runtime.Stack(buf[:], false) //转存堆栈信息

    fmt.Println(string(buf[:n])) 
}   

func main() {
    defer printStack()
    f(3)
}  
```

- 方法
    - func (p Point) Distance() float64 表达式p.Disatance称作选择子（为p选择合适的子方法）  
    - Go可以将方法绑定到任何类型上（如数字、字符串、slice、map甚至函数等定义附加行为）
    - (*Point).ScaleBy，圆括号必须，没有表达式被解析*(Point.ScaleBy)
    - 习惯上遵循如果类型的任何一个方法是使用指针接收者，那么所有的该类型的方法都应该使用指针接收（虽然部分方法不一定需要使用指针接收）(2种方式定义的方法都属于该类型的方法)  
    - 本身是指针类型不能作为接收者（假设可以，那么*指针类型是不是跟原有的类型混淆）

```go
type Point struct {
    X, Y float64
}

type PP *Point

// PP作为接收者是非法的
func (x PP) test(){ 

}

```

- “.”同样适用于结构体相当于其它语言的“->”，go编译器会对变量进行隐式的转换（必须`能够隐式的转换`），合法的方法调用表达式有以下几种：

```go
type Point struct {
    X, Y float64
}

//接收者Point类型
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X - p.X, q.Y - p.Y)
}

func main() {
    a := Point{ 10, 11}
    b := Point{ 11, 12}

    fmt.Println(b.Distance(a)) //合法，Point类型
    fmt.Println(Point{1,2}.Distance(a)) //合法，Point类型
    fmt.Println((&Point{2,3}).Distance(a)) //合法，*Point类型隐式转成Point类型
}	
```

```go
type Point struct {
    X, Y float64
}

//接收者*Point类型
func (p *Point) Distance(q Point) float64 {
    return math.Hypot(q.X - p.X, q.Y - p.Y)
}

func main() {
    a := Point{ 10, 11}
    b := Point{ 11, 12}

    fmt.Println(b.Distance(a)) //合法，Point类型转成*Point类型
//  fmt.Println(Point{1,2}.Distance(a)) //不合法，类型字面量无法获取地址不能隐式转换
    fmt.Println((&Point{2,3}).Distance(a)) //合法，*Point类型
}
```

- Go匿名类型展开，查找`先在当前类型的方法中查找`，再到成员类型中查找方法，当`同一级出现同名的会报错`（模拟两可选择错误，但可以明确指明调用哪个成员的方法）。

```go
type t1 struct {}

func (t t1) test() {
    fmt.Println("t1test")
}

type t2 struct {}

func (t t2) test() {
    fmt.Println("t2test")
}

type t3 struct {
    t1
}

type t4 struct {
    t3
}

func (t t4) test() {
    fmt.Println("t4test")
}

type t5 struct {
    t1
    t2
}

func main() {
    var a t4
    a.test() //t4test

    var b t5
    b.t1.test() //t1test

    var b t5
    b.test() //ambiguous selector b.test (test模棱两可)
}

```

- vim 滚屏
Ctrl + F 屏幕向下滚动一屏  
Ctrl + B 屏幕向上滚动一屏  
Ctrl + E 屏幕向下滚动一行  
Ctrl + Y 屏幕向上滚动一行  
Ctrl + D 屏幕向下滚动半屏  
Ctrl + U 屏幕向上滚动半屏  

- 位向量（使用`二进制位做数据存储`），以下例子使用“二维”数组存储（一维存储64个数据，二维也存储64个数据）

```go
package main

import(
    "fmt"
    "bytes"
)

type IntSet struct {
    words []uint64
}

func (s *IntSet) Has(x int) bool {
    word, bit := x / 64, uint(x % 64)
    return word < len(s.words) && s.words[word] & (1 << bit) != 0
}

func (s *IntSet) Add(x int) {
    word, bit := x / 64, uint(x % 64)
    fmt.Println(word,bit)
    for word >= len(s.words) {
        s.words = append(s.words, 0)
    }

    s.words[word] |= 1 << bit
}

func (s *IntSet) UnionWith(t *IntSet) {
    for i, tword := range t.words {
        if i < len(s.words) {
            s.words[i] |= tword
        } else {
            s.words = append(s.words, tword)
        }
    }
}

func (s *IntSet) String() string {
    var buf bytes.Buffer
    buf.WriteByte('{')
    for i, word := range s.words {
        if word == 0 {
            continue
        }

        for j := 0; j < 64; j++ {
            if word & (1 << uint(j)) != 0 {
                if buf.Len() > len("{") {
                    buf.WriteByte(' ')
                }
                fmt.Fprintf(&buf, "%d", 64 * i + j)
            }
        }
    }

    buf.WriteByte('}')
    return buf.String()
}

func main() {
    var x, y IntSet
    x.Add(1)
    x.Add(144)
    x.Add(9)
    fmt.Println(x.String())

    y.Add(9)
    y.Add(42)
    fmt.Println(y.String())

    x.UnionWith(&y)
    fmt.Println(x.String())
    fmt.Println(x.Has(9), x.Has(123))
}

```

- Go封装一个对象，必须使用结构体（通过大小写是否导出），Go封装的单元是包而不是类型  

### 变量
- `:=`省略var，左侧没有`声明新的变量`，产生编译错误（常用于初始化声明）

```go
    var intVal int
    intVal := 1 //编译错误intVal不是新的变量
	g,h := 123,"test" //只能在`函数体中`出现
````

- 因式分解关键字写法用于声明全局变量

```go
var(
	a int
	b bool
)
````

- 局部变量声明未使用编译错误，全局变量声明未使用是允许的  


### 常量
- iota常量（可被编译器修改的常量），`const出现iota重置为0`。const`语句块中每行+1`

```go
package main

import "fmt"
const (
    i=1<<iota
    j=3<<iota
    k
    l
)

func main() {
    fmt.Println("i=",i)
    fmt.Println("j=",j)
    fmt.Println("k=",k)
    fmt.Println("l=",l)
}

输出结果：
i=1
j=6
k=12
l=24

//k=3<<iota(1+1) l=3<<iota(1+1+1)
```

### 运算
- go`不支持前++`，i++是一种语句，而非表达式（不同于C族语言，`j = i++ 是不合法的`）

### select语句（随机版switch）
- select随机一个可运行的case，可运行退出
- 若无default子句，select会阻塞，循环检测条件直到满足才退出循环

### Go默认的`值传递`，调用过程不会影响到实际参数

### Slice(切片)，即可扩容“动态数组”
````go
var slice []int = make([]int,10) //定义长度10的切片
s := slice[startIndex:endIndex] //复制切片从指定的位置，默认值切片起止位置
````

### Map(集合)

var myMap map[int]string //声明变量，若`无初始化是nil` map不能存放键值对（slice切片也是一样） 
myMap = make(map[int]string) //创建集合，此时才能修改map

### Interface接口（方法的集合）
- 接口`只能定义`方法，具体的由实现接口的类提供
- 定义对象`必须实现`的成员，定义方式同时结构体
- 接口不能直接实例化

### 错误处理
- 实现error接口的错误处理

### 并发、channel
- Go支持语言并发，通过go关键字开启goroutine
- goroutine轻量级线程，调度由Golang运行时进行管理
- goroutine两个之间传递通过channel（通道）