---
layout: post
title: 'Golang'
date: 2019-09-09
author: smakry
tags: GO 阅读笔记
---

> 简洁、快速、安全

> 并行、有趣、开源
 
> 内存管理、数组安全、编译迅速

## Go笔记

Go强类型化的语言，具有垃圾回收机制，并显示支持并编程，Go原生地支持Unicode，可以处理所有国家的语言  
<https://github.com/golang/go/wiki/NonEnglish>  

- GOPATH目录可以是任意的，唯一的要求是`不能是你安装Go的目录`  
<https://go-zh.org/doc/code.html>  

- linux下git  
<https://blog.csdn.net/qq_42303254/article/details/89230332>

go游戏框架  
<https://github.com/liangdas/mqant/wiki>

- import “()”里的导入顺序最终会被gofmt工具按照字母顺序表进行排序  
- range产生键值对，当不使用其中的键或者值要用"_"下划线表示（空标识符），Go不允许存在无用的临时变量  
- range的for循环迭代顺序是随机（无序的）  
- 格式化类型verb（动词），下表不完整还有更多  
verb | 描述
%d 		 |十进制整数  
%x,%o,%b |十六进制，八进制，二进制数  
%f,%g,%e |浮点数：如3.141593，3.141592653589793，3.141593e+00  
%t		 |布尔型：true或者false  
%c		 |字符（Unicode码点）  
%s		 |字符串  
%q		 |带引号字符串（如"ABC"）或者字符（如'C'）  
%v		 |内置格式的任何值  
%T		 |任何值的类型  
%%		 |百分号本身（无操作数）  

-go关键字
break	|default	|func	|interface	|select	  
case	|defer		|go		|map		|struct  
chan	|else		|goto	|package	|switch  
const	|fallthrough|if		|range		|type  
continue|for		|import	|return		|var  

- 内置的预声明的常量、类型和函数  
常量：true	false	iota	nil  

类型：  
int		|int8	|int16		|int32	|int64  
uint	|uint8	|uint16		|uint32	|uint64	|uintptr  
float32	|float64|complex64	|complex128  
bool	|byte	|rune		|string	|error  

函数：  
make	|len	|cap	|**new**	|append	|copy	|close	|delete	  
complex	|real	|imag	|panic	|recover  

- 包里函数外的全局函数，`大写开头的函数其它包可见`，包名总是小写字母组成  
- 函数调用可在声明之前，函数和其它包级别的实体可以以`任意次序`声明  
- map是一个使用make创建的数据结构的`引用`（变量别名）  
- GO有escape analysis，在编译期，它会分析你的变量是否在函数执行完毕那一刻，程序有没有可能有别的对象引用到它（所谓逃逸，`逃逸的在堆上分配`），如果没有，那这个变量就可以在栈上分配，完全不经过gc。如果它已经逃逸了，那什么时候gc就由不得你了。(go build 加上-gcflags='-m'会显示escape内容)<https://blog.csdn.net/weixin_42117918/article/details/82024667>
    - 对于`包一级声明的变量`来说，它们的`生命周期和整个程序的运行周期一致`；
    - 而`局部变量`生命周期则是`动态`的：每次从创建一个新变量的声明语句开始，直到该变量`不再被引用为止`，然后变量的存储空间`可能`被回收。
- 字符串变量声明方式  
- 初始值对于类型的零值（数值是0；布尔值是false；字符串是""；对于接口和引用类型（slice、指针、map、通道、函数）是nil；对于像数组或结构体这样的符合类型，零值是其所有元素或成员的零值），go里面不存在未初始化变量    

```go
s := "" //常用于函数内局部变量（常用）  
var s string //常用于包内，默认初始化""（常用）
var s = "" //由初值判定类型
var s string = "" //显示变量类型
```

- func (t Time) Second() int{} //Time类型的一个方法Second()  
- 当一个goroutine试图在一个通道上进行发送或者接收操作时，它会`阻塞`，直到另一个goruntine试图进行接收或者发送操作才传递值（读写锁？）  
- switch中case从上到下推演，但是default可以放到任何位置  
- go`指针不支持算术运算`

### 变量
- `:=`省略var，左侧没有`声明新的变量`，产生编译错误（常用于初始化声明）

```go
    var intVal int
    intVal := 1 //编译错误intVal不是新的变量
	g,h := 123,"test" //只能在`函数体中`出现
````

- 因式分解关键字写法用于声明全局变量

```go
var(
	a int
	b bool
)
````

- 局部变量声明未使用编译错误，全局变量声明未使用是允许的

### 常量
- iota常量（可被编译器修改的常量），`const出现iota重置为0`。const`语句块中每行+1`

```go
package main

import "fmt"
const (
    i=1<<iota
    j=3<<iota
    k
    l
)

func main() {
    fmt.Println("i=",i)
    fmt.Println("j=",j)
    fmt.Println("k=",k)
    fmt.Println("l=",l)
}

输出结果：
i=1
j=6
k=12
l=24

//k=3<<iota(1+1) l=3<<iota(1+1+1)
```

### 运算
- go`不支持前++`，i++是一种语句，而非表达式（不同于C族语言，`j = i++ 是不合法的`）

### select语句（随机版switch）
- select随机一个可运行的case，可运行退出
- 若无default子句，select会阻塞，循环检测条件直到满足才退出循环

### Go默认的`值传递`，调用过程不会影响到实际参数

### Slice(切片)，即可扩容“动态数组”
````go
var slice []int = make([]int,10) //定义长度10的切片
s := slice[startIndex:endIndex] //复制切片从指定的位置，默认值切片起止位置
````

### Map(集合)

var myMap map[int]string //声明变量，若`无初始化是nil` map不能存放键值对（slice切片也是一样） 
myMap = make(map[int]string) //创建集合，此时才能修改map

### Interface接口（方法的集合）
- 接口`只能定义`方法，具体的由实现接口的类提供
- 定义对象`必须实现`的成员，定义方式同时结构体
- 接口不能直接实例化

### 错误处理
- 实现error接口的错误处理

### 并发、channel
- Go支持语言并发，通过go关键字开启goroutine
- goroutine轻量级线程，调度由Golang运行时进行管理
- goroutine两个之间传递通过channel（通道）