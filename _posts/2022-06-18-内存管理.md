---
layout: post
title: '内存管理'
date: 2022-06-18
author: smakry
tags: 内存分配 垃圾收集 栈内存管理
---

>

### 内存分配

1. 线性分配器
2. 空闲链表分配器

#### 分配应用

1. 业务模块预分配空间
    - 业务内存空间相对固定，重用内存分配相关的从该空间释放及分配
    - 业务波动场景，内存申请可能存在资源浪费
    - 空间固定，不利于伸缩
    - 减少产生内存碎片的可能
    - 适用场景内存块申请空间大
    - 读多写少的情况

2. 空闲内存块分配
    - 业务申请的内存块相对小
    - 频繁读写
    - 系统调用带来的切换
    
    2.1 首次适应（循环找到第一个足够的内存块）
    2.2 循环首次适应（从上次找的可使用的内存点之后继续循环查找）
    2.3 最优适应（全部遍历完，知道最优）
    2.4 隔离适应（将内存分割为不同级别大小的内存块，分配需求根据大小对应级别选择）（Go语言的内存分配策略相对类比这种策略）

3. 结合使用，内存块一次性申请，用于比较固定的内存申请使用，直接管理内存块。读写带来的锁等方面效率会急剧下降。 
    - C与Go混合使用的场景
    - 混合多种策略调度资源消耗
    - 带来内存空间浪费
    - 空间污染

### 垃圾收集

1. 标记清除
    分2个阶段，标记和清除，清除阶段STW（stop the world），清除阶段其余程序需要中断，存在长时间的STW。

2. 三色标记
    - 白色，潜在的垃圾
    - 黑色，活跃对象，没用引用其它对象
    - 灰色，活跃对象，存在引用其它的对象，垃圾收集器需要扫描对应的子对象

3. 三色标记的可能？
    - 存在引用，导致内存无法被垃圾收集收集并清除
    - 子对象遍历释放资源，同时执行垃圾回收

### go GC

1. Golang GC大部分处理和用户代码并行
2. GC过程可能会有新的对象分配和指针赋值，这个过程会STW。
3. GC会`扫描`全局指针和栈
4. GC清扫工作上一轮结束才回开始新的一轮
5. 辅助GC（GC回收的速度跟不上用户代码分配对象的速度？）
    扫描后回收速度跟不上分配的速度，会暂停用户线程，同时抢占用户线程加入垃圾回收，这就是辅助回收。
6. GC 时机：
    - 内存分配达到阀值。每次分配内存都会检查当前内存分配量是否达到阀值。（阀值=上次GC内存分配量 x 内存增长率） （内存增长率：debug.SetGCPercent(百分比)）
    - 定时触发GC，默认2分钟触发一次
    - 手动触发（runtime.GC()）

### go GC调优
1. 减少对象的分配，合理重复利用
2. 避免string与[]byte转化（两者发生转化的时候，底层数据结构会进行复制，导致GC效率变低）
3. 少量使用+连接string。（string是只读类型，针对它的操作都会创建新的string。少量文本拼接用“+”即可；大量小文本拼接用string.Join；大量大文本拼接用bytes.Buffer）

### go 程序内存占用大的问题
1. go的垃圾回收有触发阀值，阈值会随着内存的使用变大而逐渐增大（当阈值增大后，大块内存申请无法通过阈值触发GC）。
2. go交还内存给系统知识告诉系统这些内存不需要使用了，可以回收。系统没有立即回收，等内存紧张时才会开始回收。（可以强制返还给系统：debug.FreeOSMemory()）












