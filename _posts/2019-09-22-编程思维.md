---
layout: post
title: '编程思维'
date: 2019-09-22
author: smakry
tags: 方法论
---

> 编程方法论    

## 目录  

- [动态规划的思想](#list_1)
- [类兔乌龟赛跑思路](#list_2)
- [不使用第3变量交换2个值](#list_3)
- [二进制异或特性](#list_4)

--- 

### <span id = "list_1"></span>动态规划的思想  

<https://blog.csdn.net/u013250416/article/details/80558542>  

动态规划算法思想（分治思想和解决冗余）：一个问题拆解各种`更小的相似的`子问题，子问题求解获得原问题解；子问题结果保存，同子问题再次出现无需再次求解，直接引用保存的子问题结果。

### <span id = "list_2"></span>类兔乌龟赛跑思路  

类兔乌龟赛跑的思路就是2个对象先后跑的问题：  
1.给定一个链表头结点如何判断是否有环及环的长度：    
两个指针一个走的慢走1步，一个走的快走2步，当其中一个指向了空节点（快指针会先走到空节点）则无环，当2个指针再次相遇表示有环，且环的长度为慢指针走过的长度（有环的话必定在一倍循环相遇）  
2.给定一个链表，求这个链表的倒数第k个节点：  
两个指针，第一个先走k个节点后第二个指针跟第一个同时走直到第一个节点到结束，第二个所指的就是对应的位置（需注意k节点超过链表长度），示例如下：  

```cpp
#include<iostream>

struct Node{
    int m_Data;
    Node * p_nextNode;
};

Node* getKNode(Node * root,int k){
    if (!root || k < 1){ return nullptr;}

    Node * pFir = root;
    Node * pKst = root;

    for(int iIndex = 0;iIndex < k - 1;++iIndex){
        if(!(pKst->p_nextNode)){
            return nullptr;
        }
        pKst = pKst->p_nextNode;
    }

    while(pKst->p_nextNode){
        pKst = pKst->p_nextNode;
        pFir = pFir->p_nextNode;
    }

    return pFir;
}

int main(){
    Node n5;
    n5.m_Data = 5;

    Node n4;
    n4.m_Data = 4;
    n4.p_nextNode = &n5;

    Node n3;
    n3.m_Data = 3;
    n3.p_nextNode = &n4;
    n3.p_nextNode = &n4;

    Node n2;
    n2.m_Data = 2;
    n2.p_nextNode = &n3;

    Node n1;
    n1.m_Data = 1;
    n1.p_nextNode = &n2;

    n5.p_nextNode = nullptr;  //此处必须赋值空指针，要不上面while遍历结尾会出现访问0xCCCCCCCC（野指针）
    Node* res = getKNode(&n1,8);

    if(res){
        std::cout << res->m_Data << std::endl;
    }

    return 0;
}

```  

3.给定一个链表，求这个链表的中间节点  

两个指针，一个走2步一个走1步，当快的下一步是空时候（表示链表结束），慢的指针指向的即链表中间。  

### <span id = "list_3"></span>不使用第3变量交换2个值  

1.**差值计算**：计算A、B两者之间的差值（“河”宽），交易“河”宽达成你我互换。例如：  

```cpp  
int A = 11;
int B = 23;

A = A - B;  //A比B多出来的宽
B = B + A;  //B加上A多出来的宽就变成了B
A = B - A； //如今的B（已经是原来的A的大小）减去原来A比B多出来的宽就是原来B的值

```  

2.**指针地址计算**：利用指针a + 10（表示以a为基地址在a后10个a类数据单元的地址），之后同1的方法，但需注意在转化过程数据类型的精度跟操作系统寻址有关，且地址操作不能出现负数，例如：  

````cpp  
#include<iostream>

int main() {
	long int *a = new long int(10);  //long int的原因是int不能表示64位寻址地址
	long int *b = new long int(20);

	if (a > b) {  //地址不出现负数
		a = (long int*)(a - b);
		b = (long int*)(b + (long int)a);
		a = (long int*)(b - (long int)a);
	}
	else {
		b = (long int*)(b - a);
		a = (long int*)(a + (long int)b);
		b = (long int*)(a - (long int)b);
	}

	std::cout << *a << " " << *b << std::endl;
	return 0;
}

````

3.**位运算**：利用异或的特性（一个数与给定的一个值异或2次值不变）  

```cpp
#include<iostream>

int main(){
    int a = 11; // 01011
    int b = 23; // 10111

    a ^= b;     // 11100
    b ^= a;     // 01011
    a ^= b;     // 10111

    std::cout << a << " " << b << std::endl;
    return 0;
}
```  

4.**利用栈或队列等**：这种方式只是把变量转成其它的数据结构（如果允许这种方式也可行）  

### <span id = "list_4"></span>二进制异或特性  

1.一个数A异或给定的一个值B偶数次还是A，eg：  
int a = 11；  
a = a ^ 123 ^ 123;  //结果为a

2.一个数A异或自己奇数次为0，异或偶数次还是自己A  
int a = 11;
a = a ^ a;  //结果为0
