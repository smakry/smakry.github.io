---
layout: post
title: '程序问题整合'
date: 2019-09-19
author: smakry
tags: 笔记
---

> 十万个为什么，没有那么多为什么  

## 目录  

- [结构体内存对齐问题？](#list_1)
- [字符指针和字符数组的区别](#list_2)
- [C++中class与struct的区别](#list_3)
- [c++虚函数和纯虚函数](#list_4)
- [C++的动态绑定的概念](#list_7)
- [inline可以用虚函数实现吗？](#list_5)
- [函数调用入栈顺序](#list_6)

--- 

### <span id = "list_1"></span>结构体内存对齐问题  

#### 为什么要内存对齐？  

- 平台原因（移植）：不是所有的硬件平台都能访问`任意地址上`的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。  
- 性能问题：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存`只需要访问一次`。  
 
#### 结构体内存对齐要求：  

<https://blog.csdn.net/weixin_40853073/article/details/81451792>

- 每个成员的偏移量必须是`其类型大小的整数倍`  
- 结构体的大小必须是`最大成员`大小的整数倍  

```cpp
struct st {
	char e;
	int f;
};

struct stu {
	int a; //4个字节
	double b; //8个字节

	struct st stemp; //展开结构体（第一个成员偏移量为展开前结构体的最大成员的整数倍）
	int arry[10]; //1个4字节10个40字节，不能看做整体
	char c; //1个字节
	char *p; //4个字节
};

void main() {
	struct stu s1;
	printf("stu = %d,\na = %d,\nb = %d,\nstemp = %d,\narry = %d,\nc = %d,\np = %d,\nstruct size:%d\n",
		&s1, &(s1.a), &(s1.b), &(s1.stemp), &(s1.arry), &(s1.c), &(s1.p), sizeof(s1));

	system("pause");
}
```  

代码输出结果：

stu = 42578<u>00</u>, //结构体的地址即`结构体中首个元素的地址`   
a = 42578<u>00</u>, //结构体中首个元素（偏移量为0，0看做任何成员整数倍)    
b = 42578<u>08</u>, //起始地址是“a + 8”，`可通过“a + 8”访问`，8即偏移量（类型大小的整数倍）    
stemp = 42578<u>16</u>,  
arry = 42578<u>24</u>,  
c = 42578<u>64</u>,  
p = 42578<u>68</u>, //88-28 + 4  
struct size :72   

### <span id = "list_2"></span>字符指针和字符数组的区别

- 内存分配：指针是只分配指针的空间大小，数组分配了整个数组的大小空间
- 赋值含义：指针赋值只是赋值地址，数组赋值是拷贝数据到数组
- 赋值方式：指针是字符串的地址，`数组是元素一一复制赋值`
- 值的使用：指针需通过地址获得字符值，数组可以直接使用  

### <span id = "list_3"></span>C++中class与struct的区别  

- class默认的访问权限是private，struct是public
- class默认的继承方式是private，struct是public
- class可以用来定义模板参数，struct不行  

### <span id = "list_4"></span>c++虚函数和纯虚函数  

<https://www.runoob.com/w3cnote/cpp-virtual-function.html>  

#### 虚函数  

- 定义一个函数为虚函数`不代表不被实现`
- 定义虚函数为了允许基类指针来调用子类的这个函数  
- 定义为`纯虚函数才代表函数没有被实现`  
- 虚函数类似一个规范，告诉继承于他的子类必须实现它（这个虚函数是一个接口）  
- 类函数调用不是在编译时候确定，而是在`运行时候确定`（“动态联编”或“推迟联编”）。虚函数的虚在于编写时候不知道是调用基类的函数还是子类的。  
- 虚函数是c++用于实现多态（Polymorphism）的机制，核心理念就是`通过基类访问派生类定义的函数`  
- 有`动态分配堆上内存`的时候，析构函数`必须是虚函数`，但没有必要是纯虚函数。（删除一个`基类指针`的时候，c++不管这个指针指向一个基类对象还是一个派生类对象，调用的都是`基类的析构函数`,这种情况依赖派生类析构的资源不会被析构，资源泄露 <https://blog.csdn.net/qq826364410/article/details/88914802>）

```c++
#include<iostream>

class A{
public:
    A(){ std::cout << "this is ctor of A" << std::endl; }
    virtual ~A(){ std::cout << "this is del of A" << std::endl; } //若不声明为虚函数，删除基类指针只会调用“~A()”,不会调用基类的析构
    virtual void printA() = 0;
};

class B:public A{
public:
    B(){ std::cout << "this is ctor of B" << std::endl; }
    ~B(){ std::cout << "this is del of B" << std::endl; }
    void printA(){
        std::cout << "this is B overrid A" << std::endl;
    }
};

int main(){
    A *b = new B(); //基类用子类赋值
    b->printA();
    delete b;

    return 0;
}

/*
输出结果:
this is ctor of A
this is ctor of B
this is B overrid A
this is del of B
this is del of A
*/
```  

#### 纯虚函数（儿子我告诉你有这个东西，至于他是什么样子的你说了算）  

定义为纯虚函数的方式：  
virtual [return] function(Params) = 0;  //“= 0”告诉子类必须实现它,若不是“= 0”子类可以不实现该方法（不是纯虚函数）  
类中存在`纯虚函数的不能实例化`（存在没有实现的虚函数，我只是一个说明我并不存在）  

引入纯虚函数的原因：  
- 效率：为了方便实现多态  
- 安全：基本对象本身函数的实现没有实际意义（eg：动物类，本身生成对象没有意义）  

```cpp  

#include<iostream>

class A{
public:
 virtual void printA() = 0;  //纯虚函数
};

class B:public A{
public:
 void printA(){
     std::cout << "this is B overrid A" << std::endl;
 }
};

int main(){
 A *b = new B();  //抽象类不能定义实例，但**可以声明指向实现该抽象类的具体类的指针或引用**
 b->printA();

 return 0;
}

```

#### 抽象类  

- 带有纯虚函数的类为抽象类
- 类继承了于抽象类，但未实现纯虚函数，那么继承类还是一个抽象类  

### <span id = "list_7"></span>C++的动态绑定的概念  

- 静态绑定：`编译时`绑定，通过`对象`调用
- 动态绑定：`运行时`绑定，通过`地址`实现  
只有采用“指针->函数()”或“引用变量.函数()”方式调用C++类中的虚函数才会执行动态绑定，因此`非虚函数不存在动态绑定`。

### <span id = "list_5"></span>inline可以用虚函数实现吗  
  
inline函数是在编译时候动态的展开代码，而虚函数是在运行时候动态调用，所以不能。

#### inline函数

- 为何要有inline？  
小函数（代码`片段很小`的，复制大的不适合做内联函数）但有频繁调用，栈内存开销大（函数在代码区，函数内的变量在栈中）。  
- inline是在`编译时候处理`的，同时也只是给编译器一个`建议`，编译器最后可能不内联  
- inline的类型：  

```cpp
#include<iostream>

class A{
public:
    //类里面定义的函数，默认是inline
    void funcA(int x,int y){
        std::cout << "funcA" << std::endl;                 
    }   
}   

///////////////////////////////////////////////////  
//head file
class B{
public:
    void funcB(int x,int y);
}

//define file(相比在类中直接定义这种方式的内联比较好)
inline void funcB(int x,int y){}

///////////////////////////////////////////////////  
//这种方式内联在声明中不是内联
inline void funcC(int x,int y);
void funcC(int x,int y){} 

//这种方式内联在定义中是内联
void funcC(int x,int y);
inline void funcC(int x,int y){} 

```

### <span id = "list_5"></span>函数调用入栈顺序  

函数调用过程，第一个进栈的是主调函数中调用函数的`下一条执行语句的地址`；接下来是函数的各个参数，对于绝大部分的C/C++编译器来说`参数是从右到左顺序入栈`的；接下里就是函数的局部变量入栈（`不包括静态局部变量`）。当函数调用结束的时候局部变量先退栈接着是函数参数，最后栈顶指针指向主调函数的下一条执行的命令继续执行。  

![函数调用入栈顺序]()