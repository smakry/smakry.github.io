---
layout: post
title: '程序问题整合'
date: 2019-09-19
author: smakry
tags: 笔记
---

> 十万个为什么，没有那么多为什么  

## 目录  

- [结构体内存对齐问题？](#list_1)
- [字符指针和字符数组的区别](#list_2)
- [C++中class与struct的区别](#list_3)
- [C++虚函数和纯虚函数](#list_4)
- [C++的动态绑定的概念](#list_7)
- [inline可以用虚函数实现吗？](#list_5)
- [函数调用入栈顺序](#list_6)
- [友元类友元函数](#list_8)
- [C++多态的概念和实现机制](#list_9)
- [虚函数是如何实现多态机制](#list_16)
- [堆栈的区别](#list_10)
- [sizeof和strlen区别](#list_11)
- [C的malloc和C++的new的区别](#list_12) 
- [strcpy和memcpy区别](#list_13)
- [memcpy和memmove区别](#list_14)
- [#define与typedef](#list_15)
- [面向实现和面向接口编程区别](#list_17)
- [C++const的使用](#list_18)
- [#define dosomething do {xxx} while(0)宏定义的目的](#list_19)
- [为什么析构函数不能抛出异常？](#list_20)
- [构造函数可以抛出异常？](#list_21)
- [C++什么时候用到拷贝构造函数](#list_22)
- [为什么拷贝构造函数的第一个参数必须是引用类型](#list_23)
- [overload与override区别](#list_24)

--- 

### <span id = "list_1"></span>结构体内存对齐问题  

#### 为什么要内存对齐？  

- 平台原因（移植）：不是所有的硬件平台都能访问`任意地址上`的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。  
- 性能问题：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存`只需要访问一次`。  
 
#### 结构体内存对齐要求：  

<https://blog.csdn.net/weixin_40853073/article/details/81451792>

- 每个成员的偏移量必须是`其类型大小的整数倍`  
- 结构体的大小必须是`最大成员`大小的整数倍  

```cpp
struct st {
	char e;
	int f;
};

struct stu {
	int a; //4个字节
	double b; //8个字节

	struct st stemp; //展开结构体（第一个成员偏移量为展开前结构体的最大成员的整数倍）
	int arry[10]; //1个4字节10个40字节，不能看做整体
	char c; //1个字节
	char *p; //4个字节
};

void main() {
	struct stu s1;
	printf("stu = %d,\na = %d,\nb = %d,\nstemp = %d,\narry = %d,\nc = %d,\np = %d,\nstruct size:%d\n",
		&s1, &(s1.a), &(s1.b), &(s1.stemp), &(s1.arry), &(s1.c), &(s1.p), sizeof(s1));

	system("pause");
}
```  

代码输出结果：

stu = 42578<u>00</u>, //结构体的地址即`结构体中首个元素的地址`   
a = 42578<u>00</u>, //结构体中首个元素（偏移量为0，0看做任何成员整数倍)    
b = 42578<u>08</u>, //起始地址是“a + 8”，`可通过“a + 8”访问`，8即偏移量（类型大小的整数倍）    
stemp = 42578<u>16</u>,  
arry = 42578<u>24</u>,  
c = 42578<u>64</u>,  
p = 42578<u>68</u>, //88-28 + 4  
struct size :72   

### <span id = "list_2"></span>字符指针和字符数组的区别

- 内存分配：指针是只分配指针的空间大小，数组分配了整个数组的大小空间
- 赋值含义：指针赋值只是赋值地址，数组赋值是拷贝数据到数组
- 赋值方式：指针是字符串的地址，`数组是元素一一复制赋值`
- 值的使用：指针需通过地址获得字符值，数组可以直接使用  

### <span id = "list_3"></span>C++中class与struct的区别  

- class默认的访问权限是private，struct是public
- class默认的继承方式是private，struct是public
- class可以用来定义模板参数，struct不行  

### <span id = "list_4"></span>c++虚函数和纯虚函数  

<https://www.runoob.com/w3cnote/cpp-virtual-function.html>  

#### 虚函数  

- 定义一个函数为虚函数`不代表不被实现`
- 定义虚函数为了允许基类指针来调用子类的这个函数  
- 定义为`纯虚函数才代表函数没有被实现`  
- 虚函数类似一个规范，告诉继承于他的子类必须实现它（这个虚函数是一个接口）  
- 类函数调用不是在编译时候确定，而是在`运行时候确定`（“动态联编”或“推迟联编”）。虚函数的虚在于编写时候不知道是调用基类的函数还是子类的。  
- 虚函数是c++用于实现多态（Polymorphism）的机制，核心理念就是`通过基类访问派生类定义的函数`  
- 有`动态分配堆上内存`的时候，析构函数`必须是虚函数`，但没有必要是纯虚函数。（删除一个`基类指针`的时候，c++不管这个指针指向一个基类对象还是一个派生类对象，调用的都是`基类的析构函数`,这种情况依赖派生类析构的资源不会被析构，资源泄露 <https://blog.csdn.net/qq826364410/article/details/88914802>）

```c++
#include<iostream>

class A{
public:
    A(){ std::cout << "this is ctor of A" << std::endl; }
    virtual ~A(){ std::cout << "this is del of A" << std::endl; } //若不声明为虚函数，删除基类指针只会调用“~A()”,不会调用基类的析构
    virtual void printA() = 0;
};

class B:public A{
public:
    B(){ std::cout << "this is ctor of B" << std::endl; }
    ~B(){ std::cout << "this is del of B" << std::endl; }
    void printA(){
        std::cout << "this is B overrid A" << std::endl;
    }
};

int main(){
    A *b = new B(); //基类用子类赋值
    b->printA();
    delete b;

    return 0;
}

/*
输出结果:
this is ctor of A
this is ctor of B
this is B overrid A
this is del of B
this is del of A
*/
```  

#### 纯虚函数（儿子我告诉你有这个东西，至于他是什么样子的你说了算）  

定义为纯虚函数的方式：  
virtual [return] function(Params) = 0;  //“= 0”告诉子类必须实现它,若不是“= 0”子类可以不实现该方法（不是纯虚函数）  
类中存在`纯虚函数的不能实例化`（存在没有实现的虚函数，我只是一个说明我并不存在）  

引入纯虚函数的原因：  
- 效率：为了方便实现多态  
- 安全：基本对象本身函数的实现没有实际意义（eg：动物类，本身生成对象没有意义）  

```cpp  

#include<iostream>

class A{
public:
 virtual void printA() = 0;  //纯虚函数
};

class B:public A{
public:
 void printA(){
     std::cout << "this is B overrid A" << std::endl;
 }
};

int main(){
 A *b = new B();  //抽象类不能定义实例，但**可以声明指向实现该抽象类的具体类的指针或引用**
 b->printA();

 return 0;
}

```

#### 抽象类  

- 带有纯虚函数的类为抽象类
- 类继承了于抽象类，但未实现纯虚函数，那么继承类还是一个抽象类  

### <span id = "list_7"></span>C++的动态绑定的概念  

- 静态绑定：`编译时`绑定，通过`对象`调用
- 动态绑定：`运行时`绑定，通过`地址`实现  
只有采用“指针->函数()”或“引用变量.函数()”方式调用C++类中的虚函数才会执行动态绑定，因此`非虚函数不存在动态绑定`。

### <span id = "list_16"></span>虚函数是如何实现多态机制  

多态机制的实现主要是通过子类重写基类的虚函数来实现的，而虚函数的实现机制则是通过一张虚函数表（<https://blog.csdn.net/qican_7/article/details/100603461>）。如果一个`类有虚函数`，那么这个类的`实例化对象的内存首地址`就是虚函数表的地址，每个对象都有一个指针指向这个虚函数表。程序运行的时候，`基类指针`（此处必须是指针，非指针类型做不到多态）根据所指向的不同对象的虚函数表动态的选择所要运行的函数，从而实现多态性。  

### <span id = "list_5"></span>inline可以用虚函数实现吗  
  
inline函数是在编译时候动态的展开代码，而虚函数是在运行时候动态调用，所以不能。

#### inline函数

- 为何要有inline？  
小函数（代码`片段很小`的，复制大的不适合做内联函数）但有频繁调用，栈内存开销大（函数在代码区，函数内的变量在栈中）。  
- inline是在`编译时候处理`的，同时也只是给编译器一个`建议`，编译器最后可能不内联  
- inline的类型：  

```cpp
#include<iostream>

class A{
public:
    //类里面定义的函数，默认是inline
    void funcA(int x,int y){
        std::cout << "funcA" << std::endl;                 
    }   
}   

///////////////////////////////////////////////////  
//head file
class B{
public:
    void funcB(int x,int y);
}

//define file(相比在类中直接定义这种方式的内联比较好)
inline void funcB(int x,int y){}

///////////////////////////////////////////////////  
//这种方式内联在声明中不是内联
inline void funcC(int x,int y);
void funcC(int x,int y){} 

//这种方式内联在定义中是内联
void funcC(int x,int y);
inline void funcC(int x,int y){} 

```

### <span id = "list_6"></span>函数调用入栈顺序  

函数调用过程，第一个进栈的是主调函数中调用函数的`下一条执行语句的地址`；接下来是函数的各个参数，对于绝大部分的C/C++编译器来说`参数是从右到左顺序入栈`的；接下里就是函数的局部变量入栈（`不包括静态局部变量`）。当函数调用结束的时候局部变量先退栈接着是函数参数，最后栈顶指针指向主调函数的下一条执行的命令继续执行。  

![函数调用入栈顺序](https://github.com/smakry/smakry.github.io/raw/master/imags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%A5%E6%A0%88%E9%A1%BA%E5%BA%8F.png)  

### <span id = "list_8"></span>友元函数友元类  

类的友元函数是`定义在类外部`，但`有权访问`类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数`并不是成员函数`。友元是函数即友元函数，友元是类即友元类。  
友元函数没有this指针：    
- 要访问非static成员时，需要对象做参数  
- 访问static成员或者全局变量是不需要（同其它的访问，参数如果是全局的也不需要对象做参数）  
- 友元函数直接调用，不需要通过对象或者指针  

```cpp

class A{
public:
    A(int a,int b){
        this->a = a;
        this->b = b;
    }
    void print();
//  friend void countData(A a){}  //非类成员函数不能将定义放到类内
    friend void countData(A a);
    friend class B;
private:
    int a;
    int b;
};

class B{
public:
	//类B是A的友元类，可以直接访问A的private成员
    void print(A a){
        std::cout << "this is class B:" << a.a + a.b << std::endl;
    }
};

void A::print(){

}

void countData(A a){
    std::cout << a.a + a.b << std::endl; //友元没有this指针需通过对象或指针访问
}

int main(){
    A *a = new A(10,11);
    countData(*a);  // 友元不是类方法可直接调用

    B b;
    b.print(*a);

    return 0;
}
```  

### <span id = "list_9"></span>C++多态的概念和实现机制  

- 多态指的是`基类的指针有`多种形态，简单概括为“一个接口，多种方法”，这是面向对象的核心概念  
- 多态利用虚函数来实现，依靠`虚函数表`在运行的时候动态绑定  
- C++中有两种多态：  
    - 动态多态：利用继承和虚函数来实现  
    - 静态多态：利用函数重载和运算符重载实现（<https://www.runoob.com/cplusplus/class-member-access-operator-overloading.html>）  

### <span id = "list_10"></span>堆栈的区别  

- 分配方式和回收方式的区别：  
    - 栈：由系统自动分配，并且在声明周期结束后系统自动回收
    - 堆：手动申请（例如new和malloc），释放需要手动释放（例如delete和free），如未释放会导致内存泄露  
- 申请效率：  
    - 栈：由系统分配，速度较快，效率高
    - 堆：手动申请一般比较慢，且容易产生内存碎片  
- 存储内容：
    - 栈：主要用于存储运行时候的局部变量、参数、地址等
    - 堆：主要储存new出来的数据类型等  

### <span id = "list_11"></span>sizeof和strlen的区别

size_t strlen ( const char * str );  

- sizeof是`操作符`，strlen是库函数  
- sizeof的参数可以是数据类型也可以是变量；而strlen只能是以'\0'结尾的字符串作为参数（以参数的值为首地址，`遇到第一个'\0'的长度`）  
- 编译器在`编译的时候`就计算出了sizeof的结果，sizeof计算的是数据类型占内存的大小；strlen是在`运行的时候`才能算出，计算的是字符串的长度  
- 数据传递给sizeof不会退化；传递给strlen会退化为指针（`strlen是函数，函数形参里面的数据会退化为指针`）

```cpp  

#include<iostream>
#include<string.h>

int main(){
    char a = 'a';
    char c = 'd';
    char b = '\0'; //用来strlen判定结束
    char arry[10] = "nihaoma";
    
    std::cout << "sizeof:" << sizeof(a) << "\t" << sizeof(arry) << std::endl;
    std::cout << "strlen:" << strlen(&a) << "\t" << strlen(arry) << std::endl;

    int arry2[11];
    std::cout << "arry2:" << sizeof(arry2) << std::endl;

    return 0;
}

运行结果：
sizeof:1	10
strlen:2	7      //strlen(&a)不是1
arry2:44

```  

### <span id = "list_12"></span>C的malloc和C++的new的区别  

malloc/free和new/delete都可以用来动态分配内存  
- malloc/free是C语言用来动态分配内存和释放的`函数`，malloc向堆申请一块内存，成功`返回void指针`（void*表示不确定类型的指针，可以强制转化），这块内存不使用时通过free释放，并把指向这块内存的指针设为NULL  
- new/delete是C++用来为某一个数据类型对象分配内存的`操作符`，可以被重载。new从堆申请内存成功后返回`指向具体数据类型的指针`。new在为类对象申请内存空间会去调用类的构造函数，在delete释放会调用析构函数  

### <span id = "list_13"></span>strcpy和memcpy区别  

char * strcpy ( char * destination, const char * source ); //返回值是指向destination的指针  
void * memcpy ( void * destination, const void * source, size_t num ); //Copy block of memory（`复制内存块`），void*表示不确定类型的指针  

char * strncpy ( char * destination, const char * source, size_t num ); 
void * memset ( void * ptr, int value, size_t num ); //Fill block of memory（内存块前num用value填充，value转化为unsigned char）  

- strcpy只能用于复制字符串，memcpy可以用来复制任意的内容  
- strcpy复制不需要指定长度但遇到'\0'时马上结束，memcpy需要指定长度  

### <span id = "list_14"></span>memcpy和memmove区别  

void * memcpy ( void * destination, const void * source, size_t num ); //Copy block of memory（`复制内存块`），void*表示不确定类型的指针  
void * memmove ( void * destination, const void * source, size_t num );  

memcpy和memmove的作用都是从source区域复制一定大小的内容到destination。唯一的区别当内存发生局部重叠（内存重叠：拷贝的目的地址在源地址范围内，目的地址和源地址有重叠部分），`memmove保证复制是正确的`，memcpy不保证复制是正确的，但是`memcpy复制速度快`（无需考虑重叠的开销）。  

### <span id = "list_15"></span>#define与typedef  

- #define:`文本替换`，无脑替换，`预处理器`完成
- typedef：
    - 任何声明变量的语句前面加上typedef后，原来是变量的都成了类型，例如以下两种（效果一样）：    
typedef int my_int;  
int typedef my_int;  
	- typedef定义的新类型使用时候`省略括号`，例如以下两种（效果一致）:  
typedef int my_int;
my_int a = 10;
my_int(a) = 10;   

    - typedef快速解析（拿掉typedef剩下的原来表示的含义是啥，然后再把原来的变量名拿来作为新类型），例如：  
<https://blog.csdn.net/hai008007/article/details/80651886>  

typedef int a;  
typedef int *p;    
typedef int a[];//拿掉后声明了数组a，a拿来作为新类型  
typedef int f();//拿掉后声明了函数f，f拿来作为新类型（无参数返回int的函数类型f）
typedef int g(int);//拿掉后声明了带int参数的函数g，g拿来作为新类型（带一个int参数返回值int的函数类型g） 
typedef void(*func)(void);//拿掉后声明了一个无返回值无参的函数指针func  

### <span id = "list_17"></span>面向实现和面向接口编程区别  

1. 面向实现编程：把所有的逻辑`代码全部写在一起`，代码耦合度高并且不能够实现多态  
2. 面向接口编程：系统设计者设计出一套方法让`各自去实现`，就像在C++中子类去实现虚基类（抽象类）的虚函数一样，纯虚函数就是一个接口让各自的子类去实现，这样做代码耦合度低，便于扩展有利于实现多态。

### <span id = "list_18"></span>C++const的使用（良好习惯：常量定义为大写字母）  

const常量（constant，不变的，不易改变），常量是固定值，又叫字面量（简单理解就是字面的意思）。  
定义常量的方式有两种：  
- 使用#define`预处理器`（预处理器做简单的文本替换就是文本字面的值）
- 使用const`关键字`（编译过程实现）  

```cpp
void main(){
	const int a = 7;
	int *p = (int *)&a; //强制转化，未转化编译器报错
	*p = 8;
	std::cout << a << " " << *p << std::endl;
}
输出结果：
7 8

```  

```cpp
void main(){
	volatile const int a = 7; //volatile与const相反表示可变的
	int *p = (int *)&a; //强制转化，未转化编译器报错
	*p = 8;
	std::cout << a << " " << *p << std::endl;
}
输出结果：
8 8

```

1. 定义常量：“const 数据类型 NAME = val;” 和 “数据类型 const NAME = val;”等价，数据类型的变量NAME都不可改变

2. 指针使用const（`const在谁前面谁就是常量`）
    - 指针常量（指针的常量，修饰指针，指针不能变）：int * const p = &a;表示指针p是一个常量不可改变
    - 常量指针（常量的指针，修饰常量，指针可以变）：const int *p = &a;表示p指向一个常量
    - 指向常量的指针常量（指针不变且指向的常量也不变）：const int * const p = &a;表示p是一个指针，指向的a是一个常量

3. 函数const（参数const和返回值const）  
    - 函数参数const
        -  void print (const int a); //a在函数体print内不能被修改
        -  void print (int *const a); //指针a在函数体print内不能重赋值
        -  自定义类型的参数传递，需要临时对对象复制参数，对于临时对象的复制，需要调用构造函数，比较浪费时间，因此采用const外加引用传递的方式。  
    - 函数返回值const
        - const int print();  //修饰内置类型与不修饰作用一致
        - const Custom-Type print(); //修饰自定义类型Custom-Type作为返回值，此时返回值不能被赋值也不能被修改
        - const修饰返回的指针或者引用，是否返回一个指向const的指针，取决于我们想让用户做什么

```cpp
#include<iostream>
#include<string.h>

struct B {
	int today;
};

class A {
public:
	A(int data) {
		this->data = data;
	}

	int getData() const {  //此处在print常量引用中用到需const函数
		return data;
	}

	int getData2() {  //此处暂无其它常量引用调用到无需const函数
		return data * 2;
	}
private:
	int data;
};

void print(const A & a) {
	std::cout << a.getData() << std::endl;
}

const B printB() {
	B b;
	b.today = 22;
	return b;
}

int main() {
	A a(11);
	a.getData();
	print(a);
	
	//printB().today = 21; //错误，返回值B是const的
	int c = printB().today; //正常

	getchar();
	return 0;
}

```  
4. const修饰类成员函数

const修饰成员函数表示`不允许修改类的成员变量`。  
void print() const; //const放到函数最后，防止被调用对象修改调用对象的值，如果我们`不想修改一个调用对象的值，所有成员函数都应当声明为const成员函数`。（**此处const和static不能同时使用，static修饰的成员函数是没有this指针的，即不能被实例化,被看做是一个全局函数，`const成员函数必须具体到某一具体实例`）

```cpp
#include<iostream>
#include<string.h>

class A{
public:
    void print() const {
        ++dataA;  //错误，print是const固不能修改A的成员数据
        ++dataB;  //正常，dataB被mutable（易变，容易改变）修饰后可被修改
    }
private:
    int dataA;
    mutable int dataB; //mutable修饰
};

int main(){
    return 0;
}

```  

### <span id = "list_19"></span>#define dosomething do {xxx} while(0)宏定义的目的  

<https://blog.csdn.net/tianxieeryang/article/details/86687065>  

“#define”宏预处理时纯粹的文本替换，但当出现多行时候会出现语句块问题，while(0)保证包裹的语句块能正常运行  

```cpp
#include<iostream>

#define PI 3.141592
#define MIN(a,b) (a < b ? a : b)
#define ERRO(msg) #msg
#define ERRO2(x,y) x ## y
#define func() do {print1();print2();} while(0)

void print1(){
    std::cout << "print1" << std::endl;
}

void print2(){
    std::cout << "print2" << std::endl;
}

int main(){
    std::cout << PI << std::endl;
    std::cout << MIN(5,6) << std::endl;

    std::cout << ERRO(this is erro msg) << std::endl; //将括号内内容转成字符串显示
    int xy = 123;
    std::cout << ERRO2(x,y) << std::endl;  //将括号内的参数拼接成一个字符串

    if(1)
        func();  //若不是dosomething do {xxx} while(0)包裹的，此处if(1)语句块只有"print1()"

    return 0;
}


//以上代码预处理后的结果
void print1(){
 std::cout << "print1" << std::endl;
}

void print2(){
 std::cout << "print2" << std::endl;
}

int main(){
 std::cout << 3.141592 << std::endl;
 std::cout << (5 < 6 ? 5 : 6) << std::endl;

 std::cout << "this is erro msg" << std::endl;
 int xy = 123;
 std::cout << xy << std::endl;

 if(1)
  do {print1();print2();} while(0);  //块

 return 0;
}

```

### <span id = "list_20"></span>为什么析构函数不能抛出异常？  

#### c++异常  


<https://blog.51cto.com/9291927/2164586>  
<https://www.runoob.com/cplusplus/cpp-exceptions-handling.html>  

1.函数的异常声明规格说明：  
void func(); //默认情况，可能抛出任何异常  
void func()throw(char,int);//自定义抛出异常的类型：char，int  
void func()throw();//不抛出任何异常  

```cpp
#include <iostream>
#include <string>

using namespace std;
//声明抛出的异常类型为int,char,string
void func(int i, int j)throw(int,char,string)
{
    if(0 < j && j < 10)
    {
        throw j;
    }
    if(10 < j && j < 100)
    {
        throw 'A';
    }
    else
    {
        throw string("string exception.");
    }
}

void test(int i)try  //test声明时候的异常处理，此处是声明不是定义
{
    func(i,i);
}
catch(int i)
{
    cout << "catch(int i): " << i << endl;
}
catch(char c)
{
    cout << "Exception:" << c << endl;
}
catch(string s)
{
    cout << s << endl;
}
catch(...)
{
    cout << "Exception:" << endl;
}

int main(int argc, char *argv[])
{
    test(115);//string exception.
    test(1);//catch(int i): 1
    test(20);//Exception:A
    return 0;
}
```  

2.异常匹配自上而下严格匹配（按逻辑顺序从上往下匹配，若有派生类和基类都抛出异常，必须把派生类的异常放到前面，以定位正确的抛出异常位置）

```cpp  
#include<iostream>
#include<exception>

class A{
};

class B:public A{
public:
    void print() const{ //存在常量引用此处函数需const
        std::cout << "print exception of B" << std::endl;
    }
};

int main(){
    try{
        B b;
        throw b;
    }
    catch(const B& e){ //异常自上而下严格匹配，所以此处需先catch子类
        std::cout << "exception child" << std::endl;
        e.print();
    }
    catch(const A& e){
        std::cout << "exception parent" << std::endl;
    }

    return 0;
}
```  

3.自定义异常

通过继承和重载exception类定义新的异常，what()是异常类提供的公共方法，返回异常产生的信息（char*类型）

```cpp  
#include<iostream>
#include<exception>

class NewException : public std::exception{
public:
    const char* what() const throw(){ //throw()是异常规格说明
//      this->m_Data = 11; //函数被修饰为const将不能改变类成员
        return "this is NewException";
    }

private:
    int m_Data;
};

int main(){
    try{
        throw NewException();
    }catch(NewException& e){
        std::cout << e.what() << std::endl;
    }

    return 0;
}
```

#### 类继承  

- 一个派生类继承了`除以下外的所有`的基类方法：  
    - 基类的构造函数、析构函数和拷贝构造函数
    - 基类的重载操作符
    - 基类的友元函数（非成员函数）  

- 多继承（环装继承）导致基类对象创建多次，使用虚拟（virtual）继承（在创建对象的时候会创建一个虚表），此时基类对象只会创建一次。  

```cpp
#include<iostream>

class A{
public:
    A(){
        std::cout << "this is structure A" << std::endl;
    }
};

class C:virtual public A{ //在此处就必须采用虚继承，若到B中才采用虚继承，同样A还是会被构造2次
public:
    C(){
        std::cout << "this is structure C" << std::endl;
    }
};

class D:virtual public A{
public:
    D(){
        std::cout << "this is structure D" << std::endl;
    }
};

class B:public C,public D{
public:
    B(){
        std::cout << "this is structure B" << std::endl;
    }
};

int main(){
    B*b = new B();
    delete b;

    return 0;
}

```

#### 为什么析构函数不能抛出异常？  

1. 内存泄露：抛出异常后，析构函数没有正常执行完成，后续的释放资源的动作没有完成导致泄露。
2. 死循环异常：异常发生时候，c++机制会调用已经构造对象的析构函数释放资源，当上一个异常没有处理时又有新异常，如此循环会导致程序崩溃。
3. 析构函数异常处理（异常永远不抛出析构函数作用块）：把异常完全封装在析构函数内部，`不让异常抛出函数之外`。  

### <span id = "list_21"></span>构造函数可以抛出异常？  

构造函数可以抛出异常。构造函数用来产生一个新对象，当抛出异常对象构造失败，此时也就`不存在调用析构函数`，会存在已经被构造出来的涉及到已经分配内存的会产生内存泄露。  

### <span id = "list_22"></span>C++什么时候用拷贝构造函数  

<https://blog.csdn.net/qq_22642239/article/details/94014575>

int a(5);//直接初始化（调用的是构造函数，若为类不调用拷贝构造函数）  
int a = 5;//拷贝初始化（若为类需调用拷贝构造函数）  

如果类中没有拷贝构造函数，编译器会自定义一个（编译器自定义就不会对动态分配内存的做拷贝（浅拷贝），因为编译器只是简单的对数据成员进行`一一赋值`，若为指针，2个对象就指向同一个内存，当析构时会调用2次析构同一内存）。如果类`带有指针变量，并有动态内存分配，则它必须有拷贝构造函数`。构造函数的`第1个参数`是以下之一的都是拷贝构造函数：  
- className&  
- const className&  
- volatile className&  
- const volatile className&  

**类可以有多个拷贝构造函数？**  
类可以`同时存在多个不同类型`的拷贝构造函数。  

**拷贝构造函数被private修饰后能访问类的成员吗？**  
可以访问，拷贝构造函数还是构造函数，操作的还是类的成员，不受private限制。

拷贝构造函数是特殊的构造函数，使用`同一类`中`之前创建的对象来初始化新创建的对象`（注意这个构造函数的参数只能是引用类型，若非引用就是无限的创建），使用场景：  
1. 通过使用同一类型对象来`初始化新创建的对象`  
2. `复制对象`把它作为参数传递给函数  
3. `复制对象`并从函数返回这个对象  

```cpp
#include<iostream>

class A {
public:
	A() {
		ptr = new int[10];
		std::cout << "this is default ctor" << std::endl;
	}

	A(const A& a) {
		ptr = new int[10];
		std::cout << "this is copy ctor" << std::endl;
	}

	~A() {
		if (ptr) {
			delete ptr;
		}
		std::cout << "this is destructor" << std::endl;
	}

	void setData() {
		*ptr = 123;
	}

	void classPrint() {
		std::cout << "ptr fist data " << *ptr << std::endl;
	}
private:
	int *ptr;
	//int *ptr = new int[10]; //使用这种方式在创建对象时候即做了深度拷贝，构造函数无需手动再拷贝
};

//以下参数执行了一次拷贝构造，同时函数返回值也做了一次拷贝构造
A print(A a3) {
	std::cout << "this is print" << std::endl;
	return a3;
}

void test() {
	A a1;
	a1.setData();
	a1.classPrint();

	A a2 = a1;  //此处用一个对象赋值另一个对象，做了一次拷贝构造
	a2.classPrint();

	print(a1);
}

int main() {
	test();

	getchar();
	return 0;
}

/*输出结果
this is default ctor   //a1的构造
ptr fist data 123
this is copy ctor  //a2调用了拷贝构造
ptr fist data -842150451  //拷贝构造只是拷贝了内存空间，值不会被拷贝（值是动态运行产生的）
this is copy ctor  //这是print函数的参数a3的拷贝构造
this is print
this is copy ctor  //这是print函数的返回值的调用拷贝构造
this is destructor
this is destructor
this is destructor
this is destructor
*/
```  

### <span id = "list_23"></span>为什么拷贝构造函数的第一个参数必须是引用类型

拷贝构造函数的第1个参数必须是引用类型。假如一个对象以`值传递`的方式传入拷贝构造函数，此时参数又做了一次拷贝构造，这样将引起无限循环导致栈溢出（函数调用，变量分配内存），所以说拷贝构造函数的参数必须是引用类型。  

### <span id = "list_24"></span>overload与override区别  

1. overload(重载)，重载要求函数名必须相同，但是参数类型、参数个数、参数顺序必须要有一个不同；如果只是仅仅返回值不同不能做为重载，重载是基于参数来实现的。
2. override（重写），要求函数名、函数参数列表、返回值必须完全一样。C++中子类继承基类后可以重写基类的方法，重写的是虚函数可以实现多态，若`重写的不是虚函数没有多态的性质`。  