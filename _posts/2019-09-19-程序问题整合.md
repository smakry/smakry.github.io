---
layout: post
title: '程序问题整合'
date: 2019-09-19
author: smakry
tags: 笔记
---

> 十万个为什么，没有那么多为什么  

## 目录  

- [结构体内存对齐问题？](#list_1)
- [字符指针和字符数组的区别](#list_2)
- [C++中class与struct的区别](#list_3)
- [C++虚函数和纯虚函数](#list_4)
- [C++的动态绑定的概念](#list_7)
- [inline可以用虚函数实现吗？](#list_5)
- [函数调用入栈顺序](#list_6)
- [友元类友元函数](#list_8)
- [C++多态的概念和实现机制](#list_9)
- [堆栈的区别](#list_10)
- [sizeof和strlen区别](#list_11)
- [C的malloc和C++的new的区别](#list_12) 
- [strcpy和memcpy区别](#list_13)
- [memcpy和memmove区别](#list_14)

--- 

### <span id = "list_1"></span>结构体内存对齐问题  

#### 为什么要内存对齐？  

- 平台原因（移植）：不是所有的硬件平台都能访问`任意地址上`的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。  
- 性能问题：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存`只需要访问一次`。  
 
#### 结构体内存对齐要求：  

<https://blog.csdn.net/weixin_40853073/article/details/81451792>

- 每个成员的偏移量必须是`其类型大小的整数倍`  
- 结构体的大小必须是`最大成员`大小的整数倍  

```cpp
struct st {
	char e;
	int f;
};

struct stu {
	int a; //4个字节
	double b; //8个字节

	struct st stemp; //展开结构体（第一个成员偏移量为展开前结构体的最大成员的整数倍）
	int arry[10]; //1个4字节10个40字节，不能看做整体
	char c; //1个字节
	char *p; //4个字节
};

void main() {
	struct stu s1;
	printf("stu = %d,\na = %d,\nb = %d,\nstemp = %d,\narry = %d,\nc = %d,\np = %d,\nstruct size:%d\n",
		&s1, &(s1.a), &(s1.b), &(s1.stemp), &(s1.arry), &(s1.c), &(s1.p), sizeof(s1));

	system("pause");
}
```  

代码输出结果：

stu = 42578<u>00</u>, //结构体的地址即`结构体中首个元素的地址`   
a = 42578<u>00</u>, //结构体中首个元素（偏移量为0，0看做任何成员整数倍)    
b = 42578<u>08</u>, //起始地址是“a + 8”，`可通过“a + 8”访问`，8即偏移量（类型大小的整数倍）    
stemp = 42578<u>16</u>,  
arry = 42578<u>24</u>,  
c = 42578<u>64</u>,  
p = 42578<u>68</u>, //88-28 + 4  
struct size :72   

### <span id = "list_2"></span>字符指针和字符数组的区别

- 内存分配：指针是只分配指针的空间大小，数组分配了整个数组的大小空间
- 赋值含义：指针赋值只是赋值地址，数组赋值是拷贝数据到数组
- 赋值方式：指针是字符串的地址，`数组是元素一一复制赋值`
- 值的使用：指针需通过地址获得字符值，数组可以直接使用  

### <span id = "list_3"></span>C++中class与struct的区别  

- class默认的访问权限是private，struct是public
- class默认的继承方式是private，struct是public
- class可以用来定义模板参数，struct不行  

### <span id = "list_4"></span>c++虚函数和纯虚函数  

<https://www.runoob.com/w3cnote/cpp-virtual-function.html>  

#### 虚函数  

- 定义一个函数为虚函数`不代表不被实现`
- 定义虚函数为了允许基类指针来调用子类的这个函数  
- 定义为`纯虚函数才代表函数没有被实现`  
- 虚函数类似一个规范，告诉继承于他的子类必须实现它（这个虚函数是一个接口）  
- 类函数调用不是在编译时候确定，而是在`运行时候确定`（“动态联编”或“推迟联编”）。虚函数的虚在于编写时候不知道是调用基类的函数还是子类的。  
- 虚函数是c++用于实现多态（Polymorphism）的机制，核心理念就是`通过基类访问派生类定义的函数`  
- 有`动态分配堆上内存`的时候，析构函数`必须是虚函数`，但没有必要是纯虚函数。（删除一个`基类指针`的时候，c++不管这个指针指向一个基类对象还是一个派生类对象，调用的都是`基类的析构函数`,这种情况依赖派生类析构的资源不会被析构，资源泄露 <https://blog.csdn.net/qq826364410/article/details/88914802>）

```c++
#include<iostream>

class A{
public:
    A(){ std::cout << "this is ctor of A" << std::endl; }
    virtual ~A(){ std::cout << "this is del of A" << std::endl; } //若不声明为虚函数，删除基类指针只会调用“~A()”,不会调用基类的析构
    virtual void printA() = 0;
};

class B:public A{
public:
    B(){ std::cout << "this is ctor of B" << std::endl; }
    ~B(){ std::cout << "this is del of B" << std::endl; }
    void printA(){
        std::cout << "this is B overrid A" << std::endl;
    }
};

int main(){
    A *b = new B(); //基类用子类赋值
    b->printA();
    delete b;

    return 0;
}

/*
输出结果:
this is ctor of A
this is ctor of B
this is B overrid A
this is del of B
this is del of A
*/
```  

#### 纯虚函数（儿子我告诉你有这个东西，至于他是什么样子的你说了算）  

定义为纯虚函数的方式：  
virtual [return] function(Params) = 0;  //“= 0”告诉子类必须实现它,若不是“= 0”子类可以不实现该方法（不是纯虚函数）  
类中存在`纯虚函数的不能实例化`（存在没有实现的虚函数，我只是一个说明我并不存在）  

引入纯虚函数的原因：  
- 效率：为了方便实现多态  
- 安全：基本对象本身函数的实现没有实际意义（eg：动物类，本身生成对象没有意义）  

```cpp  

#include<iostream>

class A{
public:
 virtual void printA() = 0;  //纯虚函数
};

class B:public A{
public:
 void printA(){
     std::cout << "this is B overrid A" << std::endl;
 }
};

int main(){
 A *b = new B();  //抽象类不能定义实例，但**可以声明指向实现该抽象类的具体类的指针或引用**
 b->printA();

 return 0;
}

```

#### 抽象类  

- 带有纯虚函数的类为抽象类
- 类继承了于抽象类，但未实现纯虚函数，那么继承类还是一个抽象类  

### <span id = "list_7"></span>C++的动态绑定的概念  

- 静态绑定：`编译时`绑定，通过`对象`调用
- 动态绑定：`运行时`绑定，通过`地址`实现  
只有采用“指针->函数()”或“引用变量.函数()”方式调用C++类中的虚函数才会执行动态绑定，因此`非虚函数不存在动态绑定`。

### <span id = "list_5"></span>inline可以用虚函数实现吗  
  
inline函数是在编译时候动态的展开代码，而虚函数是在运行时候动态调用，所以不能。

#### inline函数

- 为何要有inline？  
小函数（代码`片段很小`的，复制大的不适合做内联函数）但有频繁调用，栈内存开销大（函数在代码区，函数内的变量在栈中）。  
- inline是在`编译时候处理`的，同时也只是给编译器一个`建议`，编译器最后可能不内联  
- inline的类型：  

```cpp
#include<iostream>

class A{
public:
    //类里面定义的函数，默认是inline
    void funcA(int x,int y){
        std::cout << "funcA" << std::endl;                 
    }   
}   

///////////////////////////////////////////////////  
//head file
class B{
public:
    void funcB(int x,int y);
}

//define file(相比在类中直接定义这种方式的内联比较好)
inline void funcB(int x,int y){}

///////////////////////////////////////////////////  
//这种方式内联在声明中不是内联
inline void funcC(int x,int y);
void funcC(int x,int y){} 

//这种方式内联在定义中是内联
void funcC(int x,int y);
inline void funcC(int x,int y){} 

```

### <span id = "list_6"></span>函数调用入栈顺序  

函数调用过程，第一个进栈的是主调函数中调用函数的`下一条执行语句的地址`；接下来是函数的各个参数，对于绝大部分的C/C++编译器来说`参数是从右到左顺序入栈`的；接下里就是函数的局部变量入栈（`不包括静态局部变量`）。当函数调用结束的时候局部变量先退栈接着是函数参数，最后栈顶指针指向主调函数的下一条执行的命令继续执行。  

![函数调用入栈顺序](https://github.com/smakry/smakry.github.io/raw/master/imags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%A5%E6%A0%88%E9%A1%BA%E5%BA%8F.png)  

### <span id = "list_8"></span>友元函数友元类  

类的友元函数是`定义在类外部`，但`有权访问`类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数`并不是成员函数`。友元是函数即友元函数，友元是类即友元类。  
友元函数没有this指针：    
- 要访问非static成员时，需要对象做参数  
- 访问static成员或者全局变量是不需要（同其它的访问，参数如果是全局的也不需要对象做参数）  
- 友元函数直接调用，不需要通过对象或者指针  

```cpp

class A{
public:
    A(int a,int b){
        this->a = a;
        this->b = b;
    }
    void print();
//  friend void countData(A a){}  //非类成员函数不能将定义放到类内
    friend void countData(A a);
    friend class B;
private:
    int a;
    int b;
};

class B{
public:
	//类B是A的友元类，可以直接访问A的private成员
    void print(A a){
        std::cout << "this is class B:" << a.a + a.b << std::endl;
    }
};

void A::print(){

}

void countData(A a){
    std::cout << a.a + a.b << std::endl; //友元没有this指针需通过对象或指针访问
}

int main(){
    A *a = new A(10,11);
    countData(*a);  // 友元不是类方法可直接调用

    B b;
    b.print(*a);

    return 0;
}
```  

### <span id = "list_9"></span>C++多态的概念和实现机制  

- 多态指的是`基类的指针有`多种形态，简单概括为“一个接口，多种方法”，这是面向对象的核心概念  
- 多态利用虚函数来实现，依靠`虚函数表`在运行的时候动态绑定  
- C++中有两种多态：  
    - 动态多态：利用继承和虚函数来实现  
    - 静态多态：利用函数重载和运算符重载实现（<https://www.runoob.com/cplusplus/class-member-access-operator-overloading.html>）  

### <span id = "list_10"></span>堆栈的区别  

- 分配方式和回收方式的区别：  
    - 栈：由系统自动分配，并且在声明周期结束后系统自动回收
    - 堆：手动申请（例如new和malloc），释放需要手动释放（例如delete和free），如未释放会导致内存泄露  
- 申请效率：  
    - 栈：由系统分配，速度较快，效率高
    - 堆：手动申请一般比较慢，且容易产生内存碎片  
- 存储内容：
    - 栈：主要用于存储运行时候的局部变量、参数、地址等
    - 堆：主要储存new出来的数据类型等  

### <span id = "list_11"></span>sizeof和strlen的区别

size_t strlen ( const char * str );  

- sizeof是`操作符`，strlen是库函数  
- sizeof的参数可以是数据类型也可以是变量；而strlen只能是以'\0'结尾的字符串作为参数（以参数的值为首地址，`遇到第一个'\0'的长度`）  
- 编译器在`编译的时候`就计算出了sizeof的结果，sizeof计算的是数据类型占内存的大小；strlen是在`运行的时候`才能算出，计算的是字符串的长度  
- 数据传递给sizeof不会退化；传递给strlen会退化为指针（`strlen是函数，函数形参里面的数据会退化为指针`）

```cpp  

#include<iostream>
#include<string.h>

int main(){
    char a = 'a';
    char c = 'd';
    char b = '\0'; //用来strlen判定结束
    char arry[10] = "nihaoma";
    
    std::cout << "sizeof:" << sizeof(a) << "\t" << sizeof(arry) << std::endl;
    std::cout << "strlen:" << strlen(&a) << "\t" << strlen(arry) << std::endl;

    int arry2[11];
    std::cout << "arry2:" << sizeof(arry2) << std::endl;

    return 0;
}

运行结果：
sizeof:1	10
strlen:2	7      //strlen(&a)不是1
arry2:44

```  

### <span id = "list_12"></span>C的malloc和C++的new的区别  

malloc/free和new/delete都可以用来动态分配内存  
- malloc/free是C语言用来动态分配内存和释放的`函数`，malloc向堆申请一块内存，成功`返回void指针`（void*表示不确定类型的指针，可以强制转化），这块内存不使用时通过free释放，并把指向这块内存的指针设为NULL  
- new/delete是C++用来为某一个数据类型对象分配内存的`操作符`，可以被重载。new从堆申请内存成功后返回`指向具体数据类型的指针`。new在为类对象申请内存空间会去调用类的构造函数，在delete释放会调用析构函数  

### <span id = "list_13"></span>strcpy和memcpy区别  

char * strcpy ( char * destination, const char * source ); //返回值是指向destination的指针  
void * memcpy ( void * destination, const void * source, size_t num ); //Copy block of memory（`复制内存块`），void*表示不确定类型的指针  

char * strncpy ( char * destination, const char * source, size_t num ); 
void * memset ( void * ptr, int value, size_t num ); //Fill block of memory（内存块前num用value填充，value转化为unsigned char）  

- strcpy只能用于复制字符串，memcpy可以用来复制任意的内容  
- strcpy复制不需要指定长度但遇到'\0'时马上结束，memcpy需要指定长度  

### <span id = "list_14"></span>memcpy和memmove区别  

void * memcpy ( void * destination, const void * source, size_t num ); //Copy block of memory（`复制内存块`），void*表示不确定类型的指针  
void * memmove ( void * destination, const void * source, size_t num );  

memcpy和memmove的作用都是从source区域复制一定大小的内容到destination。唯一的区别当内存发生局部重叠（内存重叠：拷贝的目的地址在源地址范围内，目的地址和源地址有重叠部分），`memmove保证复制是正确的`，memcpy不保证复制是正确的，但是`memcpy复制速度快`（无需考虑重叠的开销）。  

