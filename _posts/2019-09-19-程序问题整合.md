---
layout: post
title: '程序问题整合'
date: 2019-09-19
author: smakry
tags: 笔记
---

> 十万个为什么，没有那么多为什么  

## 目录  

- [结构体内存对齐问题？](#结构体内存对齐问题)

### 结构体内存对齐问题  

#### 为什么要内存对齐？  

- 平台原因（移植）：不是所有的硬件平台都能访问`任意地址上`的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。  
- 性能问题：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存`只需要访问一次`。  
 
#### 结构体内存对齐要求：  

<https://blog.csdn.net/weixin_40853073/article/details/81451792>

- 每个成员的偏移量必须是`其类型大小的整数倍`  
- 结构体的大小必须是`最大成员`大小的整数倍  

```cpp
struct st {
	char e;
	int f;
};

struct stu {
	int a; //4个字节
	double b; //8个字节

	struct st stemp; //展开结构体（第一个成员偏移量为展开前结构体的最大成员的整数倍）
	int arry[10]; //1个4字节10个40字节，不能看做整体
	char c; //1个字节
	char *p; //4个字节
};

void main() {
	struct stu s1;
	printf("stu = %d,\na = %d,\nb = %d,\nstemp = %d,\narry = %d,\nc = %d,\np = %d,\nstruct size:%d\n",
		&s1, &(s1.a), &(s1.b), &(s1.stemp), &(s1.arry), &(s1.c), &(s1.p), sizeof(s1));

	system("pause");
}
```  

代码输出结果：

stu = 42578<u>00</u>, //结构体的地址即`结构体中首个元素的地址` 
a = 42578<u>00</u>, //结构体中首个元素（偏移量为0，0看做任何成员整数倍)  
b = 42578<u>08</u>, //起始地址是“a + 8”，`可通过“a + 8”访问`，8即偏移量（类型大小的整数倍）  
stemp = 42578<u>16</u>,
arry = 42578<u>24</u>,
c = 42578<u>64</u>,
p = 42578<u>68</u>, //88-28 + 4  
struct size :72  


