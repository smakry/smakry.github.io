---
layout: post
title: '线程同步'
date: 2019-10-31
author: smakry
tags: 线程同步 阅读笔记
---

>  

## 目录  

- [多线程](#list_1)

linux下多线程：
<https://www.cnblogs.com/hhbeast/p/7484877.html>  
<https://www.jianshu.com/nb/32555483>  

---

单核通过线程切换（每个任务完成一点切换一个线程）实现并发，真正的并发是在多核CPU上，同时执行多个任务（`硬件并发`）。单核需要保存CPU的状态和指令指针，算出切换哪个任务，再重新加载CPU状态（`额外的开销`所以单核多线程的花费总时间会比线程各自执行总时间更高）。使用并发的目的`任务拆分`和`提高性能`。

- 多进程并发：应用程序分为多个独立的进程同时运行 
- 多线程并发：  
    - 任务拆分：程序划分不同的任务，每个线程执行一个或者多个任务，逻辑简单
    - 提高性能：
        - 任务并行：`拆分`任务`并行执行`减少时间（并行复杂不一定能做到时间降低）  
        - 数据并行：每个线程`不同的数据`上执行`相同的操作`  

### <span id = "list_0"></span> 多线程  

### 线程同步

1、**临界区**：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。  
2、**互斥量**：采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享  
3、**信号量**：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目  
4、**事 件**： 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作  

临界区（Critical Section）：适合一个进程内的多线程访问公共区域或代码段时使用  
互斥量 (Mutex)：适合不同进程内多线程访问公共区域或代码段时使用，与临界区相似。  
事件（Event）：通过线程间触发事件实现同步互斥  
信号量（Semaphore）：与临界区和互斥量不同，可以实现多个线程同时访问公共区域数据，原理与操作系统中PV操作类似，先设置一个访问公共区域的线程最大连接数，每有一个线程访问共享区资源数就减一，直到资源数小于等于零。  
临界区和互斥器都有“线程所有权”的概念，所以它们是不能用来实现线程间的同步的，只能用来实现互斥。原因是由于创建临界区或互斥器的线程可以不用等待LeaveCriticalSection(),SetEvent()就可以无条件进入保护的程序段，因为它拥有这个权利。另外，互斥器可以很好的处理”遗弃“操作。若线程在未释放对向象的时候就意外终止的，其它线程可以等待到一个  WAIT_ABANDONED_0。但是事件和信号量都不能做到。  

事件和信号量都可以实现线程和进程间的互斥和同步。就使用效率来说，临界区的效率是最高的，因为它不是内核对象，而其它的三个都是核心对象，要借助操作系统来实现，效率相对来说就比较低。但如果要跨进程使用还是要用到互斥器、事件对象和信号量。
