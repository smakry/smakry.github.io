---
layout: post
title: '设计模式'
date: 2019-10-16
author: smakry
tags: 设计模式 阅读笔记
---

> 实践中指导解决问题的方案  

> 可复用的面向对象软件元素  

## 目录  

- [设计模式的六大原则](#list_0)
- [工厂模式](#list_1)

<https://www.jianshu.com/c/c3f6140b8315>  
<https://www.cnblogs.com/chengjundu/p/8473564.html>  

1.对接口编程而不是对实现编程  
2.优先使用对象组合而不是继承  

### <span id = "list_0"></span>设计模式的六大原则  

1.**开闭原则**（Open Close Principle）：`对扩展开放，对修改关闭`。需要扩展的地方不能修改原有的代码。  

2.**里氏替换原则**（Liskov Substitution Principle）：`基类出现的位置都可以被子类替换掉`（原始功能不受任何影响，子类才能扩展更多功能）  

3.**依赖倒转原则**（Dependence Inversion Principle）：开闭原则的基础，`针对接口编程，依赖于抽象`而不依赖于具体   

4.**接口隔离原则**（Interface Segregation Principle）：使用多个隔离的接口，比使用单个接口要好，降低依赖，降低耦合度  

5.迪米特法则（Demeter Principle）又称**最少知道原则**：一个实体尽量少与其它实体发生相互作用，功能模块相对独立，也是降低耦合度  

6.**合成复用原则**（Composite Reuse Principle）：尽量`使用合成/聚合的方式`，而不是使用继承

```cpp
class A {
public:
	void FuncOfA();
};

class B {
public:
	A a; //B合成A的功能，不通过继承的方式拥有A的功能
	void FuncOfB();
};
```  

### <span id = "list_1"></span>工厂模式  

工厂模式提供一种创建对象的最佳方式，对象的创建逻辑不会暴露给客户端，只提供一个共同的接口来指向新创建的对象（比如买车，到店里面买车，店面提供给你的是各种品牌的完整的成品车，至于车是怎么被制造出来的是由汽车制造工厂做的。`店面行使的是共同接口功能`直接提供给你成品车，`汽车工厂行使就是对象的创建逻辑`。）

##### 1.1 简单工厂模式  

商店做直接的筛选提供汽车。

```cpp
#include<iostream>

//定义产品的类型识别
typedef enum{
    Type_BMW,
    Type_Audi
} CarType;

//抽象汽车类
class Car{
public:
    virtual void CarName() = 0;
};

//具体的汽车BMW类
class BMW : public Car{
public:
    void CarName() override{
        std::cout << "This is BMW" << std::endl;
    }
};

//具体的汽车Audi类
class Audi : public Car{
public:
    void CarName() override{
        std::cout << "This is Audi" << std::endl;
    }
};

//汽车商店类
class CarShop{
public:
	//根据买家需要什么类型的汽车创建具体的汽车类，返回抽象汽车类
    Car* CreateCar(CarType type){
        switch(type){
            case Type_BMW:
                return new BMW();
            case Type_Audi:
                return new Audi();
            default:
                return nullptr;
        }
    }
};

int main(){
    CarShop* shop = new CarShop(); //到汽车商店
    Car* newCar = shop->CreateCar(Type_Audi); //买车
    if (newCar){ newCar->CarName(); }

	delete shop;
	shop = nullptr;
	delete newCar;
	newCar = nullptr;
    return 0;
}
```

##### 1.2 工厂方法模式  

到指定品牌的汽车商店买车。  

```cpp
#include<iostream>

//抽象汽车类
class Car{
public:
    virtual void CarName() = 0;
};

//具体的汽车BMW类
class BMW : public Car{
public:
    void CarName() override{
        std::cout << "This is BMW" << std::endl;
    }
};

//具体的汽车Audi类
class Audi : public Car{
public:
    void CarName() override{
        std::cout << "This is Audi" << std::endl;
    }
};

//抽象商店类
class CarShop{
public:
    virtual Car* CreateCar() = 0;
};

//具体BMW商店类
class BMWShop : public CarShop{
public:
    Car* CreateCar() override{
        return new BMW();
    }
};

//具体Audi商店类
class AudiShop : public CarShop{
public:
    Car* CreateCar() override{
        return new Audi();
    }
};

int main(){
    CarShop* shop = new BMWShop();
    Car* newCar = shop->CreateCar();
    if (newCar){ newCar->CarName(); }

	delete shop;
	shop = nullptr;
	delete newCar;
	newCar = nullptr;
    return 0;
}
```  

##### 1.3 抽象工厂模式  

到各个零件工厂拿零件组装汽车。  

```cpp
#include<iostream>

//发动起抽象类
class Engine{
public:
    virtual void EngineModel() = 0;
};

//具体的BMW发动机
class BMWEngine : public Engine{
public:
    void EngineModel() override{
        std::cout << "This is BMWEngine" << std::endl;
    }
};

//具体的Audi发动机
class AudiEngine : public Engine{
public:
    void EngineModel() override{
        std::cout << "This is AudiEngine" << std::endl;
    }
};

//抽象轮胎类
class Tire{
public:
    virtual void TireModel() = 0;
};

//具体的BMW轮胎
class BMWTire : public Tire{
public:
    void TireModel() override{
        std::cout << "This is BMWTire" << std::endl;
    }
};

//具体的Audi轮胎
class AudiTire : public Tire{
public:
    void TireModel() override{
        std::cout << "This is AudiTire" << std::endl;
    }
};

//抽象汽车类
class Car{
public:
    virtual Engine* CreateEngine() = 0;
    virtual Tire* CreateTire() = 0;
};

//具体的BMW车
class BMWCar : public Car{
public:
    Engine* CreateEngine() override{
        return new BMWEngine();
    }

    Tire* CreateTire() override{
        return new BMWTire();
    }
};

//具体的Audi车
class AudiCar : public Car{
public:
    Engine* CreateEngine() override{
        return new AudiEngine();
    }

    Tire* CreateTire() override{
        return new AudiTire();
    }
};

int main(){
    Car* myCar = new AudiCar();
    Engine* myEngine = myCar->CreateEngine();
    myEngine->EngineModel();
    Tire* myTire = myCar->CreateTire();
    myTire->TireModel();

    delete myCar;
    myCar = nullptr;
    delete myEngine;
    myEngine = nullptr;
    delete myTire;
    myTire = nullptr;

    return 0;
}

```