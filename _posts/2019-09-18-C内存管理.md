---
layout: post
title: 'C内存管理'
date: 2019-09-18
author: smakry
tags: 内存管理 阅读笔记
---

> 什么时候用栈什么时候用堆？

操作系统管理内存最小单位是内存页（32位操作系统一版是4k大小）非字节。内存页越大，内存浪费的概率越大（申请的内存大小低于4k且多），不用频繁分配和释放内存；内存页越小，虽然浪费少，但是操作系统内存调度效率低（频繁处理）。内存有限，程序设计中C是如何做到内存管理？

### 基本的一些概念  

1. 变量  
- 全局变量（外部变量）：代码块之外的  
- 局部变量（内部自动变量）：代码块之内的，可用auto修饰  
- 静态变量：程序执行过程地址`一直不变`的,关键字static修饰的
- extern修饰变量，具体情况分析，可声明可定义，extern修饰函数一定是定义    
2. 作用域：能产生作用的范围  
3. 函数：...
4. `C语言中函数默认是全局的`，使用static修饰的函数只能被定义该函数的文件访问。

### 内存四区

内存四区：代码区、静态区、堆区、栈区  

![内存四区](https://github.com/smakry/smakry.github.io/raw/master/imags/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA.png)

1. 代码区（`程序运行期间不会变化`）  
操作系统加载程序到内存，所有的可执行代码（程序代码指令、常量字符串等）都`加载到代码区`，这块内存在程序运行期间是不变的。函数也是代码的一部分。  
“int a = 0;”`加载到代码区的只有“a = 0;”`，“int a;”在程序编译的时候已完成。  
2. 静态区  
存放程序中的`**所有**的全局变量和静态变量`(包括代码块内的静态变量)。  
3. 栈区  
栈（stack）是一种先进后出的内存结构，所有的`自动变量、函数形参都存储在栈中`，这个动作由`编译器自动完成`，我们写程序时不需要考虑。栈区在程序运行期间是`可以随时修改`的。当一个自动变量超出其作用域时，自动从栈中弹出。  
    - 每个`线程`都有自己的`专属的栈`  
    - 栈的`最大尺寸固定`，超出则引起栈溢出  
    - 变量离开作用域后栈上的内存会自动释放  
    - 栈是从`高地址向低地址`方向增长  
    - C语言中，函数参数的`入栈顺序是从右到左`  

![栈结构](https://github.com/smakry/smakry.github.io/raw/master/imags/%E6%A0%88%E7%BB%93%E6%9E%84.png)  

````C
#include<stdio.h>
int n = 0;
void test(int a,int b){
	printf("address a:%d b:%d\n",&a,&b);
}

void main(){
	static int m = 0;
	int a = 0;
	int b = 0;
	printf("block address a:%d b:%d\n",&a,&b);	
	printf("global address n:%d m:%d\n",&n,&m);
	test(a,b);
	printf("function address test:%d main:%d\n",&test,&main);
}

运行结果：
block address a:26858<u>76</u> b:26858<u>64</u>  //a的地址比b的小（地址不同于实参，值拷贝）
global address n:17146168 m:17146172  //静态区按先后地址从小到达
address a:26856<u>48</u> b:26856<u>52</u>   //a的地址比b的大
function address test:17109617 main:17109677  //函数默认是全局也在静态区

````  
4. 堆区  

栈的内存大小是固定且是有限的（一般是k为单位的），当需要保存较大的数据结构时栈会溢出，那么这个时候就需要用到堆。堆同样是可以随时改变的内存区域。堆的内存延伸方向是`从小到大`跟栈是`相反的`。堆的容量比栈大得多。在C语言中，堆内存空间的`申请和释放需要手动`通过代码来完成。对于一个32位操作系统，最大管理管理4G内存，其中1G是给操作系统自己用的，剩下的3G都是给用户程序，一个用户程序理论上可以使用3G的内存空间。堆上的内存必须手动释放（C/C++），除非语言执行环境支持GC（如C#在.NET上运行就有垃圾回收机制）。  
- 如果明确知道数据占用多少内存，那么数据量较小时使用栈，较大使用堆
- 如果不知道数据量大小（可能需要较大的内存），最好用堆（保险、安全）
- 如果`需要动态创建数组，则用堆`

````C
#include<stdio.h>
#include<stdlib.h>

int *getx() {
	int *p = (int *)malloc(1024 * 1024 * 1024);  //动态创建数组，使用堆
	return p;  //函数返回了一个地址（**由于p处于堆中，函数执行结束p指向的地址没被释放**）
}

void main() {
	int *pp = getx();
	*pp = 10;  //若p不是堆在函数调用结束后就被释放也就指向一个空
	free(pp);  //pp指向的堆需手动释放
}
````