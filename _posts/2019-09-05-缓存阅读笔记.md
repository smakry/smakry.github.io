---
layout: post
title: '缓存阅读笔记'
date: 2019-09-05
author: smakry
tags: 缓存 阅读笔记
---

> 

### 1.缓存失效：
- 失效原因：
    - 大量key同一时间失效
    - 主被动场景同一时间加载一大批数据到缓存
- 失效场景：
    - 预定火车票
- 解决方案：
    - “同一时间”着手散列拆分失效时间
### 2.缓存穿透
- 穿透原因：
    - 缓存中未命中数据，DB中也未命中数据。每次请求直接穿透到DB
- 穿透场景：
    - 请求不存在的此次信息
- 解决方案：
    - 不存在的key做对应的响应，写入到缓存中（量大耗费空间），设置较短失效时间
    - 布隆过滤器，筛选有效key（过滤器越来越庞大，需定期重置）
### 3.缓存击穿（缓存失效的特例）
- 击穿原因：
    - 热点数据缓存key失效
- 击穿场景：
    - 热门新闻缓存失效，穿透到DB
- 解决方案：
    - 采用LRU(Least recently used，最近最少使用)队列将访问到的数据加队列头部，去掉队列尾部（访问的数据再次访问的概率更高，偶然访问的影响）
    - 多级LRU权重访问（访问增加访问的次数淘汰规则）
### 4.缓存雪崩
- 雪崩原因：
    - 部分节点不支持rehash导致整个缓存系统不可用
    - 洪峰流量，部分节点过载宕机，扩散其它节点导致整个系统不可用
- 雪崩场景：
    - 大量缓存节点不可用，穿透DB，DB过载
    - 分布式设计采用一致性hash，洪峰集中访问几个节点导致过载
- 解决方案：
    - DB设置开关（达到阈值关闭，低于阈值恢复后打开）
    - 多机架多副本，单个未命中读取其它副本
    - 监控缓存系统，超出阈值执行自动故障转移
### 5.数据不一致
- 不一致原因：
    - 缓存与DB，缓存副本之间存在不一致
- 不一致场景：
    - DB更新后，缓存所在机器异常导致更新失败
    - 一致性hash+rehash导致更新异常数据不一致
- 解决方案：
    - 更新淘汰失败，多次尝试，失败后将key写入消息队列，缓存正常后处理并删除key
    - 简短缓存时间，自动过期
    - 拒绝rehash策略
### 6.数据并发竞争
- 并发经常原因：
    - 高并发同时请求缓存未存在数据，穿透DB，DB压力大争
- 并发竞争场景：
    - 车票车次信息，缓存信息过期大量用户同时请求
- 并发竞争解决方案：
    - 缓存多副本，单个未命中转移
### 7.Hot key
- Hot key原因：
    - 冷数据(不常被访问的)、热数据（访问频率非常高）。新闻热点短时访问率高
- Hot key场景：
    - 热点新闻
    - 秒杀
    - 春运
- Hot key解决方案：
    - 热数据散列，存储不同节点
    - 监控扩容
    - 本地缓存，减少缓存服务器请求（本地可能多次访问）
### 8.Big key
- 数据大副本少，请求多，加载慢，DB挂（后续继续研究）