---
layout: post
title: 'C++STL'
date: 2019-09-24
author: smakry
tags: STL
---

> STL    

## 目录  

- [仿函数](#list_1)
- [C++set源码分析](#list_2)

--- 

### <span id = "list_1"></span>仿函数  

仿函数就是使用一个类看上去是函数，`重载了“（）”运算符`的一个`类`，有了类似函数功能的行为。调用仿函数实际上就是通过类对象调用重载后的operator()运算符。  
  
```cpp
class A{
public:
	A(){}
	void operator()(int iNum){}
private:
	int m_Data;
};
```  

**为什么要有仿函数？**

1. 公用方法不适宜放置类中作为成员函数（不同类需实现相同的方法）
2. 使用函数指针的方式，参数变化函数需重写；公共方法可能存在全局变量，造成命名空间污染，维护困难。
3. 仿函数是对象，有记录功能（若使用公共函数全局变量的维护难）

```cpp
#include<iostream>

class Compar{
public:
    Compar(int cpn):iCpn(cpn){}
    bool operator()(int a){ //带参的operator()
        return a > iCpn ? true : false;
    }
    bool operator()(){  //不带参的operator()
        return true;
    }

private:
    int iCpn;
};

int GetGreatMax(int *begin,int *end,Compar cpr){ //Compar以类作为形参
    int *ptr = begin;
    int iCount = 0;

    for (int *ptr = begin;ptr < end;++ptr){
        if (cpr(*ptr)){ ++iCount;}
    }

    return iCount;
}

int main(){
    int arry[] = {23,34,45,6,67};

    std::cout << GetGreatMax(arry,arry + 5,Compar(10)) << std::endl;  //此处Compar调用同函数调用方式

    return 0;
}  
```  

<https://blog.csdn.net/K346K346/article/details/82818801>  
<https://www.cnblogs.com/lutianba/archive/2013/05/18/3086287.html>

### <span id = "list_2"></span>C++set源码分析  

<https://www.jianshu.com/p/271e1ad10197>